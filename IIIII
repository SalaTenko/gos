1. Основные функции ОС. Примеры исполнения этих функций на основе современных
ОС.
Основные функции ОС
1. Управление процессами
2. Управление памятью
3. Управление файлами
4. Управление внешними устройствами
5. Защита данных
6. Администрирование
7. Интерфейс прикладного программирования
8. Пользовательский интерфейс

Основные функции операционной системы (ОС) включают управление ресурсами компьютера, управление процессами, управление памятью, управление файлами и устройствами, обеспечение безопасности и защиты данных. 

Примеры исполнения этих функций на основе современных ОС: 
1. Управление ресурсами компьютера - ОС Windows и macOS предоставляют пользователю возможность управлять ресурсами компьютера, такими как процессор, память, диск, сеть и периферийные устройства, через различные настройки и инструменты. 
2. Управление процессами - ОС Linux имеет мощную систему управления процессами, которая позволяет запускать, останавливать, приостанавливать и управлять приоритетом процессов в системе. 
3. Управление памятью - ОС Windows, macOS и Linux имеют систему управления памятью, которая позволяет эффективно использовать доступную память в системе и предотвращать переполнение памяти. 
4. Управление файлами и устройствами - ОС Windows и macOS имеют файловую систему, которая позволяет хранить и управлять файлами на диске, а также управлять подключенными устройствами, такими как принтеры и сканеры. ОС Linux имеет мощную систему управления файлами и устройствами, которая позволяет работать с файловой системой и устройствами через командную строку. 
5. Обеспечение безопасности и защиты данных - ОС Windows, macOS и Linux имеют механизмы безопасности, такие как антивирусные программы, брандмауэры и шифрование данных, которые помогают защитить компьютер и данные от вредоносных программ и хакеров.

2. Виды архитектур ядра ОС. Монолитные и микроядерные архитектуры.
Виды архитектур ядра ОС
Типы архитектур ядер операционных систем:
Монолитное ядро
Модульное ядро
Микроядро
Экзоядро
Наноядро
Гибридное ядро

Монолитные и микроядерные архитектуры.


3. Назначение и основные действия выполняемые BIOS, загрузчиком и ядром операционной системы во время загрузки ПК.
Назначение и основные действия выполняемые BIOS
Запуск компьютера без BIOS просто невозможен.
Функции программы:
• проверка наличия, и работоспособности найденного оборудования;
• поиск, загрузка и запуск операционной системы;
• установка начальных параметров оборудования.
Кратко, BIOS выполняет начальную загрузку компьютера.	
После запуска компьютера, процессор считывает программный код BIOS из постоянной памяти, и загружает его в оперативную память (RAM). Управление компьютера в этот момент фактически передано коду BIOS, который сразу считывает настройки компьютера (из той же постоянной энергонезависимой памяти), и после быстрого тестирования оборудования (работоспособность контроллеров материнской платы, и устройств, к ней присоединенных), применяет их. После чего, находит и загружает в RAM-память машинный код загрузчика операционной системы.
В дальнейшем управление компьютером передаётся непосредственно загрузчику, который начнёт поиск операционной системы. 
Сам загрузчик находится на жёстком диске, и как только BIOS его находит и отправляет в оперативную память, загрузчик начинает действовать:
включает нужный режим работы процессора, который защищает одни процессы от других;
распределяет оперативную память и сгружает туда файл с параметрами загрузки операционной системы;
загружает драйверы устройств и проверяет их цифровую подпись;
подключает файловую систему, чтобы компьютер мог полноценно работать со всеми дисками.
На финальном этапе загрузчик находит ядро операционной системы, загружает его в память и передаёт управление ему.
Ядро занимается тем, что загружает и запускает все служебные программы и скрипты:
смотрит, какое подключено железо и какие драйверы для него нужны прямо сейчас;
считывает настройки системы и запускает скрипты сразу с нужными параметрами;
запускает службы и демоны;
настраивает графический интерфейс;
включает систему входа пользователей в систему.
Смысл ядра — запустить все программы, которые будут нужны для дальнейшей работы операционной системы. В нашей аналогии со строительной бригадой, ядро — это прораб, который находится всё время на объекте от начала работ до их полного окончания. Прораб следит за ключевыми процессами и вмешивается, если что-то идёт не так. Ядро действует точно так же: обеспечивает работоспособность всей ОС и регулирует ключевые процессы.

4. Виртуальная память. Трансляция адресов в х86.
При страничной трансляции адресов (paging) виртуальная логическая память (для каждой виртуальной машины) делится на страницы одинакового (фиксированного) размера. Любая страница виртуальной логической памяти (адресуемой программой в пределах выделенных ей сегментов) может отображаться на любую область физической памяти (реально установленной оперативной). Отображение поддерживается с помощью специальных таблиц страничной трансляции адресов, в которых помимо записей, описывающих связи адресов, есть указания на присутствие/отсутствие страницы в физической памяти. Благодаря этому страница памяти, не нужная процессору в данный момент времени, может быть выгружена на устройство хранения (диск). На ее место можно загрузить нужную страницу. Заявку на загрузку нужной страницы делает сам процессор без каких-либо усилий со стороны выполняемой программы: если программе потребовалась ячейка виртуальной памяти из страницы, образа которой нет в физической памяти, вырабатывается специальное исключение. Обработчик этого исключения (это часть ОС) находит свободную физическую страницу (возможно, выгрузив на диск ту, которая, по его мнению, пока не нужна), «подкачивает» на нее с диска требуемую информацию и возвращает управление процессу, прерванному исключением. Этот процесс ничего «не заметит» (кроме некоторой задержки выполнения инструкций). Таким образом, в распоряжение всех процессов, исполняемых на компьютере псевдопараллельно, предоставляется виртуальная оперативная память, размер которой ограничен суммой объема физической оперативной памяти и области дисковой памяти, выделенной для подкачки страниц.

5. Понятие «процесса». Основные операции выполняемые над процессами.
Процессы — это одна из самых старых и наиболее важных абстракций, присущих операционной системе. Они поддерживают возможность осуществления (псевдо) параллельных операций даже при наличии всего одного центрального процессора. Они превращают один центральный процессор в несколько виртуальных. Без абстракции процессов современные вычисления просто не могут существовать.
	Пользователю довольно трудно отслеживать несколько действий, происходящих параллельно. Поэтому разработчики операционных систем за прошедшие годы создали концептуальную модель последовательных процессов, упрощающую работу с параллельными вычислениями. В этой модели все выполняемое на компьютере программное обеспечение, иногда включая операционную систему, сведено к ряду последовательных процессов, или, для краткости, просто процессов.
Процесс — это просто экземпляр выполняемой программы, включая текущие значения счетчика команд, регистров и переменных

Основные операции выполняемые над процессами.
Создание процесса
Существуют четыре основных события, приводящих к созданию процессов.
1. Инициализация системы.
2. Выполнение работающим процессом системного вызова, предназначенного для создания процесса.
3. Запрос пользователя на создание нового процесса.
4. Инициация пакетного задания.
В UNIX существует только один системный вызов для создания нового процесса — fork. Этот вызов создает точную копию вызывающего процесса. После выполнения системного вызова fork два процесса, родительский и дочерний, имеют единый образ памяти, единые строки описания конфигурации и одни и те же открытые файлы.
После создания процесса родительский и дочерний процессы обладают своими собственными адресными пространствами. Изменения в своём адресном пространстве не видны другим процессам.

Завершение процесса
Причины завершения процесса:
● обычный выход (добровольно, exit);
● выход при возникновении ошибки (добровольно);
● возникновение фатальной ошибки (принудительно);
● уничтожение другим процессом (принудительно, kill).

6. Понятие «потока». Основные операции выполняемые над потоками.

Поток существует внутри процесса. Процесс состоит из одного или более потоков. Процесс - контейнер ресурсов (исполняемые потоки, области памяти, файловые дескрипторы) и владелец потоков исполнения.

Основные операции выполняемые над потоками
● Создание потока
– запуск потоковой функции;
– передача аргументов в потоковую функцию.
● Завершение работы потока
– при завершении потоковой функции;
– по инициативе завершаемого потока;
– по инициативе другого потока.
● Получение возвращенного потоком значения

7. Линейное адресное пространство процесса. Схема организации линейного адресного
пространства процесса в ядре Linux.

Блок управления памятью (MMU) преобразует логический адрес в линейный адрес через аппаратную схему, называемую блоком сегментации, а затем вторая аппаратная схема, называемая блоком поискового вызова, преобразует линейный адрес в физический адрес.
	Каждый раз, при выполнении команды, процессор производит преобразование логического адреса в линейный адрес - 32-разрядный абсолютный адрес в памяти. После вычисления линейного адреса процессор преобразует его в физический адрес, по которому и производит обращение к памяти.

8. Межпроцессное взаимодействие в Linux. Каналы именованные и неименованные.

В Linux каналы - это один из методов межпроцессного взаимодействия. Существуют два типа каналов: именованные и неименованные.
Неименованные каналы (pipe) представляют собой однонаправленный поток данных между двумя процессами, где один процесс записывает данные в канал, а другой процесс читает их из него. Канал создается с помощью системного вызова pipe(). Каналы могут использоваться только между родственными процессами, так как они наследуют дескрипторы файлов от родительского процесса.
Именованные каналы, также называемые FIFO-файлами, позволяют нескольким процессам обмениваться данными через один и тот же канал. Именованный канал создается с помощью системного вызова mkfifo() и имеет имя в файловой системе. Все процессы, которые имеют доступ к этому файлу, могут писать в него и/или читать из него.
Именованные каналы могут быть полезны в тех случаях, когда несколько процессов должны обмениваться данными по одному каналу. Они также могут быть использованы для создания серверов, которые прослушивают определенные именованные каналы и обрабатывают запросы от клиентов.

9. Межпроцессное взаимодействие в Linux. Очередь сообщений.

Межпроцессное взаимодействие в Linux
Межпроцессное взаимодействие (IPC - Inter-Process Communication) - это механизм, который позволяет процессам в операционной системе обмениваться информацией и синхронизировать свою работу.
В Linux существуют несколько методов межпроцессного взаимодействия, таких как разделяемая память (Shared Memory), сигналы (Signals), сокеты (Sockets) и другие. Один из наиболее эффективных и быстрых методов межпроцессного взаимодействия - это использование разделяемой памяти.
Очередь сообщений
Очередь сообщений - это один из методов межпроцессного взаимодействия в операционных системах, в том числе и в Linux. Она представляет собой буфер, в котором процессы могут оставлять сообщения для других процессов.
В Linux очередь сообщений создается и управляется с помощью системных вызовов msgget(), msgsnd(), msgrcv() и msgctl(). Системный вызов msgget() создает очередь сообщений и возвращает ее идентификатор. Системный вызов msgsnd() используется для отправки сообщения в очередь, а msgrcv() - для чтения сообщения из очереди. Системный вызов msgctl() используется для управления свойствами очереди, например, ее удаления.
Очередь сообщений поддерживает разные типы сообщений с определенными идентификаторами, что позволяет процессам отправлять и получать только нужные сообщения. Также очередь сообщений может быть ограничена по размеру, что может помочь предотвратить переполнение памяти в системе.
Однако использование очередей сообщений может быть несколько менее эффективным, чем использование других методов межпроцессного взаимодействия, таких как разделяемая память или сокеты. Это связано с тем, что передача сообщения через очередь сообщений требует копирования данных, что может привести к накладным расходам на время и использование ресурсов системы.
В целом, очереди сообщений могут быть полезны для реализации асинхронного межпроцессного взаимодействия, когда процессы должны обмениваться сообщениями в отсутствие жесткой связи во времени.
10. Межпроцессное взаимодействие в Linux. Разделяемая память.

Межпроцессное взаимодействие в Linux
Межпроцессное взаимодействие (IPC - Inter-Process Communication) - это механизм, который позволяет процессам в операционной системе обмениваться информацией и синхронизировать свою работу.
В Linux существуют несколько методов межпроцессного взаимодействия, таких как разделяемая память (Shared Memory), сигналы (Signals), сокеты (Sockets) и другие. Один из наиболее эффективных и быстрых методов межпроцессного взаимодействия - это использование разделяемой памяти.
Разделяемая память
Разделяемая память - это область памяти, которую несколько процессов могут использовать одновременно. Для создания разделяемой памяти в Linux используется системный вызов shmget(), который создает объект "сегмент разделяемой памяти" с определенным размером.
Когда сегмент разделяемой памяти создан, каждый процесс, который хочет использовать этот сегмент, должен выполнить системный вызов shmat(), чтобы "прикрепить" этот сегмент к своему адресному пространству. После прикрепления сегмента разделяемой памяти каждый процесс может получать доступ к его содержимому и модифицировать его.
Для синхронизации доступа к разделяемой памяти могут использоваться мьютексы, семафоры или другие механизмы синхронизации. Когда процесс заканчивает использование сегмента разделяемой памяти, он должен выполнить системный вызов shmdt(), чтобы "открепить" этот сегмент от своего адресного пространства.
Использование разделяемой памяти позволяет быстро обмениваться большим объемом данных между процессами и уменьшить накладные расходы на IPC. Однако необходимо осторожно использовать разделяемую память, так как несинхронизированный доступ к разделяемой памяти может привести к гонкам данных и другим ошибкам.

11. Мультипрограммный режим работы операционной системы. Системный
планировщик процессов ядра Linux.
Мультипрограммный режим работы операционной системы - это режим работы, в котором несколько процессов выполняются одновременно. Операционная система переключается между процессами и выделяет каждому процессу определенное количество ресурсов, таких как процессорное время, память и ввод/вывод.
Для управления процессами в мультипрограммном режиме операционная система использует системный планировщик процессов. Системный планировщик процессов отвечает за распределение процессорного времени между процессами и определение того, какой процесс должен быть запущен следующим.
Ядро Linux имеет несколько системных планировщиков процессов, но по умолчанию используется CFS (Completely Fair Scheduler). CFS основан на концепции "справедливости" - каждому процессу выделяется примерно равное количество процессорного времени в соответствии с приоритетами. Если процесс имеет более высокий приоритет, он получает больше времени на процессоре.
Кроме того, CFS обеспечивает низкую задержку (latency) - способность быстро реагировать на появление новых задач и быстро переключаться между процессами. Это особенно важно для интерактивных приложений, таких как браузеры или текстовые редакторы, где пользователь ожидает немедленного ответа на свои действия.
Кроме CFS, в Linux существуют и другие системные планировщики процессов, такие как O(1) Scheduler, Brain Fuck Scheduler и другие, которые могут использоваться в специальных случаях. Однако CFS остается наиболее распространенным и универсальным планировщиком в Linux.

12. Определение файловой системы. Примеры файловых систем, используемых в
современных операционных системах.
Файловая система - это механизм, который операционная система использует для организации файлов на диске. Она определяет, как данные будут храниться, и как они будут доступны для чтения и записи.
Существует множество файловых систем, используемых в современных операционных системах. Некоторые из них:
NTFS (New Technology File System) - это файловая система, которая используется в операционных системах Windows. Она поддерживает различные функции, такие как шифрование файлов и сжатие данных.
FAT (File Allocation Table) - это простая файловая система, которая используется в Windows и других операционных системах. Она хранит информацию о расположении файлов на диске в таблице.
ext4 (Fourth Extended Filesystem) - это файловая система, которая используется в Linux. Она является развитием более ранних версий ext, и обеспечивает более быстрое и надежное хранение данных.
HFS+ (Hierarchical File System Plus) - это файловая система, которая используется в операционных системах macOS. Она обеспечивает поддержку журналирования файлов, что повышает надежность системы.
APFS (Apple File System) - это новая файловая система, которая появилась в macOS High Sierra. Она предоставляет более быстрое и надежное хранение данных, поддержку сжатия файлов, а также поддержку шифрования.
ZFS (Zettabyte File System) - это файловая система, которая используется во многих UNIX-подобных операционных системах, таких как FreeBSD и Solaris. Она обеспечивает защиту от потери данных, поддержку снапшотов и шифрования файлов.
exFAT (Extended File Allocation Table) - это файловая система, которая используется для обмена файлами между операционными системами, такими как Windows и macOS. Она обеспечивает поддержку файлов больших размеров и поддержку Unicode.
Каждая из этих файловых систем имеет свои особенности и предназначена для определенных целей. Операционные системы могут поддерживать несколько файловых систем, чтобы пользователи могли выбрать подходящий вариант для своих задач.

13. Механизмы синхронизации процессов/потоков в Linux.
Механизмы синхронизации для управления параллельным выполнением процессов или потоков:
Мьютексы (mutex) - это простой механизм синхронизации, который позволяет ограничить доступ к критической секции кода только одному потоку или процессу в определенный момент времени. Мьютексы могут быть блокированными или неблокированными, что позволяет выбрать между ожиданием освобождения мьютекса или возвратом ошибки в случае, если мьютекс уже заблокирован другим потоком.
Семафоры (semaphore) - это механизм синхронизации, который позволяет ограничить доступ к общему ресурсу определенному числу потоков или процессов. Семафоры используются для управления доступом к ресурсам, таким как файлы, сокеты, разделяемая память и т.д.
Условные переменные (condition variables) - это механизм синхронизации, который позволяет потокам или процессам ожидать определенных условий для продолжения выполнения. Условные переменные используются в комбинации с мьютексами для предотвращения "гонки данных" (race conditions) и ожидания событий, таких как изменение состояния общих данных.
Барьеры (barrier) - это механизм синхронизации, который позволяет задержать выполнение всех потоков или процессов до тех пор, пока все они не достигнут определенной точки в своем выполнении. Барьеры используются для синхронизации потоков в случаях, когда необходимо гарантировать, что все потоки закончили свою работу перед выполнением следующих действий.
Атомарные операции - это механизм синхронизации, который позволяет выполнять операции над общими данными атомарно, т.е. без возможности прерывания или вмешательства других потоков или процессов. Атомарные операции используются для предотвращения "гонки данных" и гарантированного выполнения критических операций в многопоточной или многопроцессорной среде.

14. Управление памятью в Linux. Динамическая память.
В Linux есть два основных типа памяти: статическая и динамическая. Статическая память выделяется на этапе компиляции программы и не может быть изменена во время выполнения. Динамическая память выделяется во время выполнения программы и может быть изменена во время ее работы.
Динамическая память в Linux выделяется с помощью системных вызовов, таких как malloc(), calloc() и realloc(). Эти вызовы выделяют блок памяти заданного размера и возвращают указатель на начало этого блока памяти. Выделенная память остается зарезервированной до тех пор, пока она не будет освобождена с помощью системного вызова free().
При управлении динамической памятью в Linux важно следить за использованием памяти, чтобы избежать утечек памяти и некорректного освобождения памяти. Утечки памяти возникают, когда программа не освобождает зарезервированную память после использования, что приводит к постепенному уменьшению доступной памяти и может привести к сбоям в работе программы. Некорректное освобождение памяти происходит, когда программа освобождает память, которая уже была освобождена ранее, что может привести к неожиданному поведению программы и сбоям в работе.
Для предотвращения утечек памяти и некорректного освобождения памяти в Linux используются инструменты, такие как Valgrind, для обнаружения и исправления проблем с управлением памятью. Также существуют рекомендации по использованию динамической памяти в Linux, такие как использование языковых конструкций, таких как умные указатели (smart pointers), и правильное освобождение памяти в нужный момент.
15. Статические и динамические библиотеки в Linux.
В Linux статические библиотеки представляют собой набор объектных файлов, содержащих функции и другие ресурсы, которые могут быть связаны непосредственно с исполняемым файлом во время компиляции. Это означает, что функции, определенные в статической библиотеке, будут скопированы в исполняемый файл, что обеспечит быстрый доступ к ним во время выполнения программы. Однако, это может привести к увеличению размера исполняемого файла и неэффективному использованию памяти, так как каждый исполняемый файл будет содержать свою копию библиотеки.
Динамические библиотеки, наоборот, являются отдельными файлами, содержащими реализацию функций и других ресурсов, которые могут быть загружены в память и использованы во время выполнения программы. Это позволяет сократить размер исполняемого файла, так как он будет содержать только ссылки на функции, а не их реализацию. Кроме того, динамические библиотеки могут быть использованы несколькими программами одновременно, что позволяет эффективнее использовать память.
В целом, использование статических или динамических библиотек зависит от конкретного случая и требований программы. Если программе нужны только определенные функции из библиотеки, то использование динамической библиотеки может быть более эффективным, тогда как если нужно обеспечить быстрый доступ к функциям и уменьшить зависимость от внешних ресурсов, то использование статической библиотеки может быть предпочтительным.
