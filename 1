Практика Программирование

Практические задания по дисциплине «Программирование»

Разработать программу на языке Си, задание оформить в виде функции и показать ее вызов из функции main()

4. Ввод-вывод информации
4.1 На вход программы поступает два целых числа, значения которых находятся в диапазоне [-30000, 30000]. Вычислить значения арифметических операций: a + b, a – b, a * b, a / b. Для a = 10 и b = 5 вывод программы должен выглядеть следующим образом:
10 + 5	= 15
10 – 5	=  5
10 * 5 = 50
10 / 5	= 2

#include <stdio.h>

void arithmetic_operations(int a, int b) {
    printf("%d + %d = %d\n", a, b, a+b);
    printf("%d - %d = %d\n", a, b, a-b);
    printf("%d * %d = %d\n", a, b, a*b);
    printf("%d / %d = %.2f\n", a, b, (float)a/b);
}

int main() {
    int a = 10;
    int b = 5;
    arithmetic_operations(a, b);
    return 0;
}

4.2 На вход программы поступает два вещественных числа, значения которых находятся в диапазоне [-30000, 30000]. Вычислить значения арифметических операций: a + b, a – b, a * b, a / b. Для a = 10 и b = 3 вывод программы должен выглядеть следующим образом:
10 + 3	= 13
10 – 3	=  7
10 * 3 = 30
10 / 3	= 0.33


#include <stdio.h>

void arithmetic_operations(float a, float b) {
    printf("%.2f + %.2f = %.2f\n", a, b, a+b);
    printf("%.2f - %.2f = %.2f\n", a, b, a-b);
    printf("%.2f * %.2f = %.2f\n", a, b, a*b);
    printf("%.2f / %.2f = %.2f\n", a, b, a/b);
}

int main() {
    float a = 10.0;
    float b = 3.0;
    arithmetic_operations(a, b);
    return 0;
}



4.3 Распечатать на экране значение введенного целого числа в десятичной, восьмеричной и шестнадцатеричной системах счисления.

#include <stdio.h>

void print_number(int num) {
    printf("Decimal: %d\n", num);
    printf("Octal: %o\n", num);
    printf("Hexadecimal: %X\n", num);
}

int main() {
    int num = 42;
    print_number(num);
    return 0;
}



4.4 Выполнить ввод значения переменных a, b, c, d, типы которых соответственно char, short, unsigned int.

#include <stdio.h>

void processVariables(char a, short b, unsigned int c) {
    // Ваш код для обработки переменных a, b и c
    printf("Значение переменной a: %c\n", a);
    printf("Значение переменной b: %hd\n", b);
    printf("Значение переменной c: %u\n", c);
}

int main() {
    char a;
    short b;
    unsigned int c;

    printf("Введите значение переменной a (тип char): ");
    scanf("%c", &a);

    printf("Введите значение переменной b (тип short): ");
    scanf("%hd", &b);

    printf("Введите значение переменной c (тип unsigned int): ");
    scanf("%u", &c);

    processVariables(a, b, c);

    return 0;
}



4.5 Какие типы данных достаточны, если входные данные не превышают число 1)? 2)? 3)? Сколько двоичных разрядов требуется для хранения этих чисел (выполнить перевод в двоичную систему счисления).
    1) f5
    2) ABFF
    3) FEFAAA


#include <stdio.h>
#include <stdint.h>

void printBinary(uint32_t num) {
    for (int i = 31; i >= 0; i--) {
        uint32_t mask = 1 << i;
        printf("%d", (num & mask) != 0);
    }
    printf("\n");
}

void analyzeNumber(uint32_t num) {
    printf("Число в двоичной системе счисления: ");
    printBinary(num);

    if (num <= 1) {
        printf("Тип данных достаточен: char\n");
    } else if (num <= 255) {
        printf("Тип данных достаточен: unsigned char\n");
    } else if (num <= 65535) {
        printf("Тип данных достаточен: unsigned short\n");
    } else {
        printf("Тип данных достаточен: unsigned int\n");
    }
}

int main() {
    uint32_t num1 = 0xf5;   // Число 1
    uint32_t num2 = 0xABFF; // Число 2
    uint32_t num3 = 0xFEFAAA; // Число 3

    printf("1) Число: %u\n", num1);
    analyzeNumber(num1);
    printf("\n");

    printf("2) Число: %u\n", num2);
    analyzeNumber(num2);
    printf("\n");

    printf("3) Число: %u\n", num3);
    analyzeNumber(num3);
    printf("\n");

    return 0;
}



5. Арифметические операции
5.1 Необходимо разработать программу, на вход которой поступает целое число. Результатом работы программы является 1, если число нечетное и 0, если четное. 

#include <stdio.h>

int isEven(int number) {
    if (number % 2 == 0) {
        return 0; // Число четное
    } else {
        return 1; // Число нечетное
    }
}

int main() {
    int number;

    printf("Введите целое число: ");
    scanf("%d", &number);

    if (isEven(number)) {
        printf("Число нечетное\n");
    } else {
        printf("Число четное\n");
    }

    return 0;
}



5.2 Необходимо разработать программу, на вход которой поступает целое число. Результатом работы программы является 1, если число четное и 0, если нечетное. 


#include <stdio.h>

int isEven(int number) {
    if (number % 2 == 0) {
        return 1; // Число четное
    } else {
        return 0; // Число нечетное
    }
}

int main() {
    int number;

    printf("Введите целое число: ");
    scanf("%d", &number);

    if (isEven(number)) {
        printf("Число четное\n");
    } else {
        printf("Число нечетное\n");
    }

    return 0;
}

5.3 Преподаватель подготовил N вариантов заданий, их нужно распределить между M студентами. Если M ≤ N, то каждый студент получает уникальный вариант. Если M > N, то распределение производится следующим образом: 
1) первые N студентов получают задания, которые совпадают с их номерами;
2) студент с номером (N+1) выполняет 1-е задание,  с номером 2N – N-е задание и так далее.
На вход программы поступает количество N вариантов и порядковый номер i  студента в списке преподавателя. Определить вариант, который необходимо выполнить студенту. 

#include <stdio.h>

int distributeVariant(int N, int M, int studentNumber) {
    if (M <= N) {
        return studentNumber; // Каждый студент получает уникальный вариант
    } else {
        int variant = (studentNumber % N == 0) ? N : studentNumber % N;
        return variant;
    }
}

int main() {
    int N; // Количество вариантов заданий
    int M; // Количество студентов
    int studentNumber; // Номер студента

    printf("Введите количество вариантов заданий (N): ");
    scanf("%d", &N);

    printf("Введите количество студентов (M): ");
    scanf("%d", &M);

    printf("Введите номер студента (i): ");
    scanf("%d", &studentNumber);

    int variant = distributeVariant(N, M, studentNumber);
    printf("Студенту с номером %d необходимо выполнить вариант %d\n", studentNumber, variant);

    return 0;
}

Либо
#include <stdio.h>

int get_variant(int n, int i) {
    if (i <= n) {
        return i;
    } else {
        int k = i - n;
        return k % (n * 2 - 2) == 0 ? n : k % (n * 2 - 2) <= n - 1 ? k % (n * 2 - 2) : n * 2 - k % (n * 2 - 2) - 1;
    }
}

int main() {
    int n, i;
    printf("Введите количество вариантов: ");
    scanf("%d", &n);
    printf("Введите номер студента: ");
    scanf("%d", &i);
    int variant = get_variant(n, i);
    printf("Студенту %d нужно выполнить вариант %d\n", i, variant);
    return 0;
}

5.4 На вход программы поступает вещественное число. Необходимо вывести его целую и дробную части, например:
Вход: 12.568
Выход: 12; 0,568


#include <stdio.h>

void printIntegerAndFractionalParts(float number) {
    int integerPart = (int)number;
    float fractionalPart = number - integerPart;

    printf("Целая часть: %d\n", integerPart);
    printf("Дробная часть: %f\n", fractionalPart);
}

int main() {
    float number;

    printf("Введите вещественное число: ");
    scanf("%f", &number);

    printIntegerAndFractionalParts(number);

    return 0;
}

5.5 На вход программы поступает вещественное число. Необходимо выполнить его арифметическое округление, например:
вход:  12.568; выход: 13
вход:  12.368; выход: 12
Реализовать решение как с использованием оператора ветвления, так и без него.


#include <stdio.h>

int roundWithBranching(float number) {
    int roundedNumber;

    if (number >= 0) {
        roundedNumber = (int)(number + 0.5);
    } else {
        roundedNumber = (int)(number - 0.5);
    }

    return roundedNumber;
}

int roundWithoutBranching(float number) {
    return (int)(number >= 0 ? number + 0.5 : number - 0.5);
}

int main() {
    float number;

    printf("Введите вещественное число: ");
    scanf("%f", &number);

    int roundedNumberWithBranching = roundWithBranching(number);
    printf("Арифметическое округление (с использованием оператора ветвления): %d\n", roundedNumberWithBranching);

    int roundedNumberWithoutBranching = roundWithoutBranching(number);
    printf("Арифметическое округление (без использования оператора ветвления): %d\n", roundedNumberWithoutBranching);

    return 0;
}

5.6 Разработать программу, демонстрирующую алгоритм обмена значений двух ячеек с использованием вспомогательной переменной и без нее.

#include <stdio.h>

void swapWithTemp(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

void swapWithoutTemp(int *a, int *b) {
    *a = *a + *b;
    *b = *a - *b;
    *a = *a - *b;
}

int main() {
    int a, b;

    printf("Введите значение a: ");
    scanf("%d", &a);

    printf("Введите значение b: ");
    scanf("%d", &b);

    printf("До обмена: a = %d, b = %d\n", a, b);

    // Обмен значениями с использованием вспомогательной переменной
    swapWithTemp(&a, &b);
    printf("После обмена с использованием вспомогательной переменной: a = %d, b = %d\n", a, b);

    // Обмен значениями без использования вспомогательной переменной
    swapWithoutTemp(&a, &b);
    printf("После обмена без использования вспомогательной переменной: a = %d, b = %d\n", a, b);

    return 0;
}



5.8 Привести два варианта решения задачи вычисления модуля вещественного числа на языке Си: с использованием операции ветвления и без. 

#include <stdio.h>

float absoluteValueWithBranching(float number) {
    if (number >= 0) {
        return number;
    } else {
        return -number;
    }
}

float absoluteValueWithoutBranching(float number) {
    int signBit = *(int*)&number >> 31;
    int result = (*(int*)&number ^ signBit) - signBit;
    return *(float*)&result;
}

int main() {
    float number;

    printf("Введите вещественное число: ");
    scanf("%f", &number);

    // Вычисление модуля с использованием операции ветвления
    float absWithBranching = absoluteValueWithBranching(number);
    printf("Модуль числа (с использованием операции ветвления): %.2f\n", absWithBranching);

    // Вычисление модуля без использования операции ветвления
    float absWithoutBranching = absoluteValueWithoutBranching(number);
    printf("Модуль числа (без использования операции ветвления): %.2f\n", absWithoutBranching);

    return 0;
}

5.9 Способы представления знаковых чисел на базе беззнаковых - дополнительный код. Разработать программу перевода знакового числа в дополнительный код.


#include <stdio.h>

int convertToTwosComplement(int number) {
    int twosComplement;

    if (number < 0) {
        twosComplement = ~(-number) + 1;
    } else {
        twosComplement = number;
    }

    return twosComplement;
}

int main() {
    int number;

    printf("Введите знаковое число: ");
    scanf("%d", &number);

    int twosComplement = convertToTwosComplement(number);

    // printf("Знаковое число: %d\n", number);
    printf("Дополнительный код: %d\n", twosComplement);

    return 0;
}

5.10 Способы представления знаковых чисел на базе беззнаковых - дополнительный код. Разработать программу перевода числа, представленного в дополнительном коде, в знаковое представление.

#include <stdio.h>

int convertFromTwosComplement(int twosComplement) {
    int number;

    if (twosComplement & (1 << (sizeof(int) * 8 - 1))) {
        number = -((~twosComplement) + 1);
    } else {
        number = twosComplement;
    }

    return number;
}

int main() {
    int twosComplement;

    printf("Введите число в дополнительном коде: ");
    scanf("%d", &twosComplement);

    int number = convertFromTwosComplement(twosComplement);

    printf("Число в дополнительном коде: %d\n", twosComplement);
    printf("Знаковое число: %d\n", number);

    return 0;
}

6. Оператор ветвления

6.1 Вычислить модуль разности двух целых чисел. Входные данные: вещественные числа x и y. 
Выходные данные: |x –  y|. Ограничения: Не допускается вычисление разности с последующим взятием модуля: нет возможности хранить отрицательное число.

#include <stdio.h>
#include <stdlib.h>

int absolute_difference(int x, int y) {
    int diff = x - y;
    if (diff < 0) {
        diff *= -1;
    }
    return diff;
}

int main() {
    int x, y, diff;

    printf("Введите два целых числа: ");
    scanf("%d %d", &x, &y);

    diff = absolute_difference(x, y);

    printf("Модуль разности чисел %d и %d равен %d", x, y, diff);

    return 0;
}



6.2 Реализовать операцию сложения чисел в дополнительном коде (4 десятичных разряда). Входные данные: целые знаковые числа x и y. Выходные данные: 
    1) дополнительные коды для входных чисел x', y'. 
    2) сумма чисел (x' + y') в дополнительном коде.
    3) знаковое представление числа (x' + y').
Указания:
 1) выполнить преобразование входных знаковых чисел в дополнительный код;
    2) реализовать алгоритм сложения чисел в дополнительном коде;
 3) выполнить преобразование полученного результата из дополнительного кода в знаковое число. 
#include <stdio.h>
#include <stdlib.h>

#define BITS 4 // количество битов для представления числа

// функция для преобразования числа в дополнительный код
int to_complement(int x) {
    if (x >= 0) {
        return x;
    } else {
        return (1 << BITS) + x;
    }
}

// функция для преобразования числа из дополнительного кода в знаковое число
int from_complement(int x) {
    if (x >= (1 << (BITS - 1))) {
        return x - (1 << BITS);
    } else {
        return x;
    }
}

// функция для сложения чисел в дополнительном коде
int add_complement(int x, int y) {
    int sum = x + y;
    if (sum >= (1 << BITS)) {
        sum -= (1 << BITS);
    }
    return sum;
}

int main() {
    int x, y, x_c, y_c, sum_c, sum;

    printf("Введите два целых числа: ");
    scanf("%d %d", &x, &y);

    // преобразование входных чисел в дополнительный код
    x_c = to_complement(x);
    y_c = to_complement(y);

    // вычисление суммы чисел в дополнительном коде
    sum_c = add_complement(x_c, y_c);

    // преобразование результата из дополнительного кода в знаковое число
    sum = from_complement(sum_c);

    printf("Дополнительный код для числа %d: %d\n", x, x_c);
    printf("Дополнительный код для числа %d: %d\n", y, y_c);
    printf("Сумма чисел в дополнительном коде: %d\n", sum_c);
    printf("Знаковое представление суммы: %d\n", sum);

    return 0;
}


6.3 Реализовать операцию вычитания чисел в дополнительном коде (4 десятичных разряда). Входные данные: целые знаковые числа x и y. Выходные данные: 
    1) дополнительные коды для входных чисел x', y'. 
  2) разность чисел x' и y' согласно правилам арифметики чисел, представленных дополнительным кодом.
    3) знаковое представление полученного результата вычитания.
Указания:
 1) выполнить преобразование входных знаковых чисел в дополнительный код;
    2) реализовать алгоритм вычитания чисел в дополнительном коде (если уменьшаемое меньше вычитаемого, то к нему прибавить 10000);
 3) выполнить преобразование полученного результата из дополнительного кода в знаковое число. 

#include <stdio.h>
#include <stdlib.h>

#define BITS 4 // количество битов для представления числа

// функция для преобразования числа в дополнительный код
int to_complement(int x) {
    if (x >= 0) {
        return x;
    } else {
        return (1 << BITS) + x;
    }
}

// функция для преобразования числа из дополнительного кода в знаковое число
int from_complement(int x) {
    if (x >= (1 << (BITS - 1))) {
        return x - (1 << BITS);
    } else {
        return x;
    }
}

// функция для вычитания чисел в дополнительном коде
int substract_complement(int x, int y) {
    // преобразование вычитаемого и уменьшаемого в дополнительный код
    int x_c = to_complement(x);
    int y_c = to_complement(y);

    // вычитание чисел в дополнительном коде
    if (x_c < y_c) {
        x_c += (1 << BITS);
    }
    int diff_c = x_c - y_c;

    // преобразование результата из дополнительного кода в знаковое число
    int diff = from_complement(diff_c);

    return diff;
}

int main() {
    int x, y, x_c, y_c, diff_c, diff;
    printf("Введите два целых числа: ");
    scanf("%d %d", &x, &y);

    // вычисление разности чисел в дополнительном коде
    diff_c = substract_complement(x, y);

    printf("Дополнительный код для числа %d: %d\n", x, to_complement(x));
    printf("Дополнительный код для числа %d: %d\n", y, to_complement(y));
    printf("Разность чисел в дополнительном коде: %d\n", diff_c);
    printf("Знаковое представление разности: %d\n", diff_c);

    return 0;
}

7. Циклические операторы
7.1 На вход программы поступает последовательность a, состоящая из N вещественных чисел. Необходимо определить значение максимального из них.

#include <stdio.h>
#include <stdlib.h>

// функция для нахождения максимального числа в последовательности
double max(double *a, int n) {
    double max = a[0];
    for (int i = 1; i < n; i++) {
        if (a[i] > max) {
            max = a[i];
        }
    }
    return max;
}

int main() {
    int n;
    printf("Введите количество чисел: ");
    scanf("%d", &n);

    double *a = (double*) malloc(n * sizeof(double));
    if (a == NULL) {
        printf("Ошибка выделения памяти\n");
        return 1;
    }

    printf("Введите %d вещественных чисел: ", n);
    for (int i = 0; i < n; i++) {
        scanf("%lf", &a[i]);
    }

    double max_num = max(a, n);
    printf("Максимальное число: %lf\n", max_num);

    free(a);

    return 0;
}


7.2 На вход программы поступает последовательность a, состоящая из N вещественных чисел. Необходимо определить значение минимального из них.

#include <stdio.h>
#include <stdlib.h>

// функция для нахождения минимального числа в последовательности
double min(double *a, int n) {
    double min = a[0];
    for (int i = 1; i < n; i++) {
        if (a[i] < min) {
            min = a[i];
        }
    }
    return min;
}

int main() {
    int n;
    printf("Введите количество чисел: ");
    scanf("%d", &n);

    double *a = (double*) malloc(n * sizeof(double));
    if (a == NULL) {
        printf("Ошибка выделения памяти\n");
        return 1;
    }

    printf("Введите %d вещественных чисел: ", n);
    for (int i = 0; i < n; i++) {
        scanf("%lf", &a[i]);
    }

    double min_num = min(a, n);
    printf("Минимальное число: %lf\n", min_num);

    free(a);

    return 0;
}


7.3 На вход программы поступает последовательность a, состоящая из N вещественных чисел. Необходимо вычислить среднее арифметическое элементов а.

#include <stdio.h>
#include <stdlib.h>

// функция для нахождения среднего арифметического чисел в последовательности
double average(double *a, int n) {
    double sum = 0;
    for (int i = 0; i < n; i++) {
        sum += a[i];
    }
    return sum / n;
}

int main() {
    int n;
    printf("Введите количество чисел: ");
    scanf("%d", &n);

    double *a = (double*) malloc(n * sizeof(double));
    if (a == NULL) {
        printf("Ошибка выделения памяти\n");
        return 1;
    }

    printf("Введите %d вещественных чисел: ", n);
    for (int i = 0; i < n; i++) {
        scanf("%lf", &a[i]);
    }

    double avg = average(a, n);
    printf("Среднее арифметическое: %lf\n", avg);

    free(a);

    return 0;
}




7.4 На вход программы поступает последовательность a, состоящая из N вещественных чисел. Необходимо вычислить количество нулей в последовательности.

#include <stdio.h>
#include <stdlib.h>

// функция для подсчета количества нулей в последовательности
int count_zeros(double *a, int n) {
    int count = 0;
    for (int i = 0; i < n; i++) {
        if (a[i] == 0) {
            count++;
        }
    }
    return count;
}

int main() {
    int n;
    printf("Введите количество чисел: ");
    scanf("%d", &n);

    double *a = (double*) malloc(n * sizeof(double));
    if (a == NULL) {
        printf("Ошибка выделения памяти\n");
        return 1;
    }

    printf("Введите %d вещественных чисел: ", n);
    for (int i = 0; i < n; i++) {
        scanf("%lf", &a[i]);
    }

    int count = count_zeros(a, n);
    printf("Количество нулей: %d\n", count);

    free(a);

    return 0;
}



7.5 На вход программы поступает последовательность a, состоящая из N целых чисел. Необходимо вычислить сумму всех положительных чисел в последовательности.

#include <stdio.h>
#include <stdlib.h>

// функция для подсчета суммы положительных чисел в последовательности
double sum_positive(int *a, int n) {
    double sum = 0;
    for (int i = 0; i < n; i++) {
        if (a[i] > 0) {
            sum += a[i];
        }
    }
    return sum;
}

int main() {
    int n;
    printf("Введите количество чисел: ");
    scanf("%d", &n);

    int *a = (int*) malloc(n * sizeof(int));
    if (a == NULL) {
        printf("Ошибка выделения памяти\n");
        return 1;
    }

    printf("Введите %d целых чисел: ", n);
    for (int i = 0; i < n; i++) {
        scanf("%d", &a[i]);
    }

    double sum = sum_positive(a, n);
    printf("Сумма положительных чисел: %.2f\n", sum);

    free(a);

    return 0;
}



7.6 На вход программы поступает последовательность a, состоящая из N целых чисел. Необходимо вычислить суммы чисел подпоследовательностей, расположенных по возрастанию, например: вход: 1 2 3 1 5 7 2 4 5 выход: 6 13 11
#include <stdio.h>
#include <stdlib.h>

// функция для вычисления сумм чисел подпоследовательностей, расположенных по возрастанию
void sum_subsequences(int *a, int n) {
    double sum = a[0];
    for (int i = 1; i < n; i++) {
        if (a[i] > a[i-1]) {
            sum += a[i];
        } else {
            printf("%.2f ", sum);
            sum = a[i];
        }
    }
    printf("%.2f\n", sum);
}

int main() {
    int n;
    printf("Введите количество чисел: ");
    scanf("%d", &n);

    int *a = (int*) malloc(n * sizeof(int));
    if (a == NULL) {
        printf("Ошибка выделения памяти\n");
        return 1;
    }

    printf("Введите %d целых чисел: ", n);
    for (int i = 0; i < n; i++) {
        scanf("%d", &a[i]);
    }

    printf("Суммы чисел подпоследовательностей, расположенных по возрастанию: ");
    sum_subsequences(a, n);

    free(a);

    return 0;
}

7.7 На вход программы поступает целое число N. Необходимо распечатать на экран все четные числа от 0 до заданного числа.

#include <stdio.h>

void print_even_numbers(int n) {
    for (int i = 0; i <= n; i += 2) {
        printf("%d ", i);
    }
    printf("\n");
}

int main() {
    int n;
    printf("Введите целое число: ");
    scanf("%d", &n);

    printf("Четные числа от 0 до %d: ", n);
    print_even_numbers(n);

    return 0;
}


7.8 На вход программы поступает десятичное число x = xn  … x3x2x1, где xi – i-й разряд числа x. Необходимо вывести разряды числа x в обратном порядке через пробел.
#include <stdio.h>

void print_reverse_digits(int n) {
    while (n > 0) {
        int digit = n % 10;
        printf("%d ", digit);
        n /= 10;
    }
    printf("\n");
}
int main() {
    int x;
    printf("Введите десятичное число: ");
    scanf("%d", &x);

    printf("Разряды числа %d в обратном порядке: ", x);
    print_reverse_digits(x);
    return 0;
}


7.9 Разработать программу. На ее вход поступает десятичное целое положительное число. Необходимо определить количество значащих разрядов в этом числе.

#include <stdio.h>

int count_digits(int n) {
    int count = 0;
    while (n > 0) {
        count++;
        n /= 10;
    }
    return count;
}

int main() {
    int x;
    printf("Введите десятичное число: ");
    scanf("%d", &x);

    printf("Количество значащих разрядов в числе %d: %d\n", x, count_digits(x));

    return 0;
}


7.10 Разработать программу. На ее вход поступает десятичное целое положительное число и номер разряда. Распечатать на экране значение соответствующего разряда. Например: 
вход: x = 123456, i = 4, выход: 2
вход: x = 123456, i = 1, выход: 5

#include <stdio.h>

int count_digits(int n) {
    int count = 0;
    while (n > 0) {
        count++;
        n /= 10;
    }
    printf("count = %d\n", count);
    return count;
}

int get_digit(int x, int i) {
    int digits = count_digits(x);
    if (i > digits) {
        printf("Ошибка: разряд %d выходит за пределы числа %d\n", i, x);
        return -1;
    }
    int divisor = 1;
    for (int j = 0; j < i; j++) {
        divisor *= 10;
    }
    return (x / divisor) % 10;
}

int main() {
    int x, i;
    printf("Введите десятичное число: ");
    scanf("%d", &x);
    printf("Введите номер разряда: ");
    scanf("%d", &i);

    int digit = get_digit(x, i);
    if (digit != -1) {
        printf("Значение разряда %d числа %d: %d\n", i, x, digit);
    }

    return 0;
}


7.11 Для квадратов чисел верны следующие равенства:
1 = 12
1 + 3 = 4 = 22
1 + 3 + 5 = 9 = 32
1 + 3 + 5 + 7 = 16 = 42
. . . . 
Используя данное свойство можно арифметически вычислить целую часть корня. Пусть x – число, для которого необходимо найти корень.
1. Если (x – 1) = 0, то √x = 1, если (x – 1) < 0, то [√x] = 0, иначе x = x – 1
2. Если (x – 3) = 0, то √x = 2, если (x – 3) < 0, то [√x] = 1, иначе x = x – 3
3. Если (x – 5) = 0, то √x = 3, если (x – 5) < 0, то [√x] = 2, иначе x = x – 5
4. Если (x – 7) = 0, то √x = 4, если (x – 7) < 0, то [√x] = 3, иначе x = x – 7

#include <stdio.h>

// Функция для вычисления целой части корня числа
int squareRoot(int x) {
	int result = 0;
	int i = 1;

	while (x >= i) {
    	x -= i;
    	i += 2;
    	result++;
	}

	return result;
}

int main() {
	int x;

	printf("Введите число: ");
	scanf("%d", &x);

	int squareRootResult = squareRoot(x);

	// Выводим результат
	printf("Целая часть корня числа: %d\n", squareRootResult);

	return 0;
}


7.12 Итерационная формула Герона задает убывающую (начиная со 2-го элемента) последовательность, которая при любом выборе  быстро сходится к величине √a (квадратный корень из числа). Рекуррентное соотношение, описывающее данную последовательность выглядит следующим образом: 
 
Реализовать программу вычисления корня по формуле Герона.

#include <stdio.h>

// Функция для вычисления целой части корня числа
int squareRoot(int x) {
	int result = 0;
	int i = 1;

	while (x >= i) {
    	x -= i;
    	i += 2;
    	result++;
	}

	return result;
}

int main() {
	int x;

	printf("Введите число: ");
	scanf("%d", &x);

	int squareRootResult = squareRoot(x);

	// Выводим результат
	printf("Целая часть корня числа: %d\n", squareRootResult);

	return 0;
}


7.13 Реализовать алгоритм вывода целой части числа в двоичной системе счисления.

#include <stdio.h>

void printBinary(int num) {
    int binary[32]; // Массив для хранения двоичных цифр
    int i = 0;

    // Обработка отрицательных чисел
    if (num < 0) {
        printf("-");
        num = -num;
    }

    // Конвертация числа в двоичную систему
    while (num > 0) {
        binary[i] = num % 2;
        num /= 2;
        i++;
    }

    // Вывод двоичных цифр в обратном порядке
    for (int j = i - 1; j >= 0; j--) {
        printf("%d", binary[j]);
    }

    printf("\n");
}

int main() {
    int number;
    printf("Введите целое число: ");
    scanf("%d", &number);

    printf("Целая часть числа в двоичной системе счисления: ");
    printBinary(number);

    return 0;
}





7.14 Реализовать алгоритм вывода дробной части числа в двоичной системе счисления.

#include <stdio.h>

void printBinaryFraction(double num, int precision) {
    printf("Дробная часть числа в двоичной системе счисления: ");

    // Обработка отрицательных чисел
    if (num < 0) {
        printf("-");
        num = -num;
    }

    // Вычисление целой части числа
    int integerPart = (int)num;

    // Вычисление дробной части числа
    double fractionalPart = num - integerPart;

    // Печать двоичной дробной части
    for (int i = 0; i < precision; i++) {
        fractionalPart *= 2;
        int bit = (int)fractionalPart;
        printf("%d", bit);
        fractionalPart -= bit;
    }

    printf("\n");
}

int main() {
    double number;
    int precision;

    printf("Введите десятичное число: ");
    scanf("%lf", &number);

    printf("Введите количество бит для дробной части: ");
    scanf("%d", &precision);

    printBinaryFraction(number, precision);

    return 0;
}




7.15 На вход программы поступает два целых числа, на экран выводится их наибольший общий делитель (НОД). Использовать линейный алгоритм.

#include <stdio.h>

int gcd(int a, int b) {
    // Применение алгоритма Евклида для нахождения НОД
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }

    return a;
}

int main() {
    int num1, num2;
    printf("Введите два целых числа: ");
    scanf("%d %d", &num1, &num2);

    int result = gcd(num1, num2);

    printf("Наибольший общий делитель (НОД): %d\n", result);

    return 0;
}





7.16 На вход программы поступает два целых числа, на экран выводится их наибольший общий делитель (НОД). Использовать алгоритм Евклида.

#include <stdio.h>

int gcd(int a, int b) {
    if (b == 0) {
        return a;
    }
    else {
        return gcd(b, a % b);
    }
}

int main() {
    int num1, num2;
    printf("Введите два целых числа: ");
    scanf("%d %d", &num1, &num2);

    int result = gcd(num1, num2);

    printf("Наибольший общий делитель (НОД): %d\n", result);

    return 0;
}

8. Вложенные циклические конструкции и массивы
8.1 Вычислить частичную сумму ряда, для заданного x и n:

#include <stdio.h>

double partial_sum(int x, int n) {
    double sum = 0;
    double term = 1;
    for (int i = 1; i <= n; i++) {
        sum += term;
        term *= x / (double)i;
    }
    return sum;
}

int main() {
    int x, n;
    printf("Введите x и n: ");
    scanf("%d %d", &x, &n);

    double sum = partial_sum(x, n);
    printf("Частичная сумма ряда: %lf\n", sum);

    return 0;
}


8.2 Вычислить частичную сумму ряда, для заданного x и n:


#include <stdio.h>

// Функция для вычисления факториала числа
int factorial(int n) {
	if (n == 0 || n == 1)
    	return 1;
	else
    	return n * factorial(n - 1);
}

// Функция для вычисления частичной суммы ряда
double computePartialSum(double x, int n) {
	double sum = 0.0;
	for (int i = 1; i <= n; i++) {
    	double term = pow(x, i) / factorial(i);
    	sum += term;
	}
	return sum;
}

int main() {
	double x;
	int n;

	printf("Введите значение x: ");
	scanf("%lf", &x);

	printf("Введите количество элементов n: ");
	scanf("%d", &n);

	double partialSum = computePartialSum(x, n);

	printf("Частичная сумма ряда: %.2lf\n", partialSum);

	return 0;
}



8.3 Вычислить частичную сумму ряда, для заданного x и n:


#include <stdio.h>

// Функция для вычисления факториала числа
int factorial(int num) {
	if (num == 0)
    	return 1;
	else
    	return num * factorial(num - 1);
}

// Функция для вычисления частичной суммы ряда
double computePartialSum(double x, int n) {
	double sum = 0;
	for (int i = 0; i < n; i++) {
    	int numerator = i + 1;
    	int denominator = factorial(2 * i + 1);
    	double term = (numerator % 2 == 0) ? -1 : 1;
    	term *= pow(x, 2 * i + 1) / denominator;
    	sum += term;
	}
	return sum;
}

int main() {
	double x;
	int n;

	printf("Введите значение x: ");
	scanf("%lf", &x);

	printf("Введите количество элементов n: ");
	scanf("%d", &n);

	double partialSum = computePartialSum(x, n);

	printf("Частичная сумма ряда: %.2lf\n", partialSum);

	return 0;
}



8.4 На вход программы поступает последовательность целых чисел. Определить НОД для соседних элементов. Например:
Вход: 21 7 10 5 15
Выход:
(21, 7) = 7
(7, 10) = 1
(10, 5) = 5
(5, 15) = 5


#include <stdio.h>

// Функция для вычисления НОД двух чисел
int gcd(int a, int b) {
	while (b != 0) {
    	int remainder = a % b;
    	a = b;
    	b = remainder;
	}
	return a;
}

// Функция для вычисления НОД для соседних элементов в последовательности
void computeGCD(int arr[], int n) {
	for (int i = 0; i < n - 1; i++) {
    	int result = gcd(arr[i], arr[i + 1]);
    	printf("(%d, %d) = %d\n", arr[i], arr[i + 1], result);
	}
}

int main() {
	int n;
	printf("Введите количество чисел: ");
	scanf("%d", &n);

	int arr[n];
	printf("Введите числа: ");
	for (int i = 0; i < n; i++) {
    	scanf("%d", &arr[i]);
	}

	printf("Выход:\n");
	computeGCD(arr, n);

	return 0;
}



8.5 На вход программы поступает последовательность целых чисел. Определить НОД для всех пар чисел в последовательности. Например:
Вход: 21 7 10 5 15
Выход:
(21, 7) = 7; (21, 10) = 1; (21, 5) = 1; (21, 15) = 1 
(7, 10) = 1; (7, 5) = 1; (7, 15) = 1 
(10, 5) = 5; (10;15) = 5; 
(5, 15) = 5; 


#include <stdio.h>

// Функция для вычисления НОД двух чисел
int gcd(int a, int b) {
	while (b != 0) {
    	int remainder = a % b;
    	a = b;
    	b = remainder;
	}
	return a;
}

// Функция для вычисления НОД всех пар чисел в последовательности
void computeGCD(int arr[], int n) {
	for (int i = 0; i < n - 1; i++) {
    	for (int j = i + 1; j < n; j++) {
        	int result = gcd(arr[i], arr[j]);
        	printf("(%d, %d) = %d; ", arr[i], arr[j], result);
    	}
    	printf("\n");
	}
}

int main() {
	int n;
	printf("Введите количество чисел: ");
	scanf("%d", &n);

	int arr[n];
	printf("Введите числа: ");
	for (int i = 0; i < n; i++) {
    	scanf("%d", &arr[i]);
	}

	printf("Выход:\n");
	computeGCD(arr, n);

	return 0;
}



8.6 На вход программы поступает последовательность целых чисел. Определить НОД всех чисел в последовательности. Например:
Вход: 21 7 10 5 15
Выход:
(21, 7, 10, 5, 15) = 1.


#include <stdio.h>

// Функция для нахождения НОД двух чисел
int gcd(int a, int b) {
	if (b == 0) {
    	return a;
	} else {
    	return gcd(b, a % b);
	}
}

// Функция для нахождения НОД последовательности чисел
int gcdOfSequence(int array[], int size) {
	int result = array[0]; // Инициализируем результат первым числом

	// Находим НОД всех чисел в последовательности
	for (int i = 1; i < size; i++) {
    	result = gcd(result, array[i]);
	}

	return result;
}

int main() {
	int n;
	int array[100];

	printf("Введите количество элементов в последовательности: ");
	scanf("%d", &n);

	printf("Введите элементы последовательности через пробел или новую строку: ");
	for (int i = 0; i < n; i++) {
    	scanf("%d", &array[i]);
	}

	int gcdResult = gcdOfSequence(array, n);

	// Выводим результат
	printf("НОД последовательности чисел: %d\n", gcdResult);

	return 0;
}



8.7 Дана последовательность действительных чисел а1, а2, ..., аn и число x. Выяснить, является ли a возрастающей или убывающей. Если является, то вставить в нее элемент x так, чтобы порядок не был нарушен. Например:
Вход: а = 3 10 15 32 12; х = 12.
Выход: 3 10 12 15 32 12
Вход: а = 40 37 32 15 14 7; х = 20.
Выход: 40 37 32 20 15 14 7
Вход: а = 40 37 50 15 14 7; х = 20.
Выход: 40 37 50 15 14 7 (не изменена).


#include <stdio.h>

void insertElement(int array[], int size, int x) {
	int i, j;

	// Проверка, является ли последовательность возрастающей или убывающей
	int increasing = 1;
	int decreasing = 1;
	for (i = 0; i < size - 1; i++) {
    	if (array[i] > array[i + 1]) {
        	increasing = 0;
    	}
    	if (array[i] < array[i + 1]) {
        	decreasing = 0;
    	}
	}

	// Если последовательность не является ни возрастающей, ни убывающей,
	// вставляем элемент x в последнию позицию
	if (!increasing && !decreasing) {
    	array[size] = x;
    	size++;
	} else {
    	// Определяем место для вставки элемента x
    	if (increasing) {
        	i = 0;
        	while (array[i] < x && i < size) {
            	i++;
        	}
    	} else { // decreasing
        	i = 0;
        	while (array[i] > x && i < size) {
            	i++;
        	}
    	}

    	// Сдвигаем элементы вправо, начиная с позиции i
    	for (j = size; j > i; j--) {
        	array[j] = array[j - 1];
    	}

    	// Вставляем элемент x в позицию i
    	array[i] = x;
    	size++;
	}

	// Выводим результат
	printf("Результат: ");
	for (i = 0; i < size; i++) {
    	printf("%d ", array[i]);
	}
	printf("\n");
}

int main() {
	int n;
	int array[100];
	int x;
	int i;

	printf("Введите количество элементов в последовательности: ");
	scanf("%d", &n);

	printf("Введите элементы последовательности через пробел или новую строку: ");
	for (i = 0; i < n; i++) {
    	scanf("%d", &array[i]);
	}

	printf("Введите число x: ");
	scanf("%d", &x);

	insertElement(array, n, x);

	return 0;
}



8.8 Реализовать алгоритм сортировки методом выбора для целых чисел. Программа предназначена для сортировки массивов, размер которых не превышает 100 элементов.
На вход поступает число N элементов в сортируемом массиве. Далее через пробел (или новую строку) подаются значения элементов. 


#include <stdio.h>

void selectionSort(int array[], int size) {
	int i, j, minIndex, temp;
	for (i = 0; i < size - 1; i++) {
    	minIndex = i;
    	for (j = i + 1; j < size; j++) {
        	if (array[j] < array[minIndex]) {
            	minIndex = j;
        	}
    	}
    	temp = array[minIndex];
    	array[minIndex] = array[i];
    	array[i] = temp;
	}
}

int main() {
	int N;

	printf("Введите количество элементов в массиве: ");
	scanf("%d", &N);

	int array[100];
	int i;

	printf("Введите значения элементов массива через пробел или новую строку: ");
	for (i = 0; i < N; i++) {
    	scanf("%d", &array[i]);
	}

	selectionSort(array, N);

	printf("Отсортированный массив: ");
	for (i = 0; i < N; i++) {
    	printf("%d ", array[i]);
	}
	printf("\n");

	return 0;
}



8.9 Разработать программу, на вход которой поступает массив целых чисел. Необходимо вычислить абсолютное и относительное количество инверсий в заданном массиве.


#include <stdio.h>

void countInversions(int array[], int size, int* absoluteCount, float* relativeCount) {
	int i, j;

	*absoluteCount = 0;
	*relativeCount = 0.0;

	for (i = 0; i < size - 1; i++) {
    	for (j = i + 1; j < size; j++) {
        	if (array[i] > array[j]) {
            	(*absoluteCount)++;
        	}
    	}
	}

	*relativeCount = (float)(*absoluteCount) / (float)((size - 1) * size / 2);
}

int main() {
	int array[100];
	int size;
	int absoluteCount;
	float relativeCount;
	int i;

	printf("Введите размер массива: ");
	scanf("%d", &size);

	printf("Введите значения элементов массива через пробел или новую строку: ");
	for (i = 0; i < size; i++) {
    	scanf("%d", &array[i]);
	}

	countInversions(array, size, &absoluteCount, &relativeCount);

	printf("Абсолютное количество инверсий: %d\n", absoluteCount);
	printf("Относительное количество инверсий: %.2f\n", relativeCount);

	return 0;
}



8.10 Реализовать алгоритм сортировки методом вставки для целых чисел. Программа предназначена для сортировки массивов, размер которых не превышает 100 элементов.
На вход поступает число N элементов в сортируемом массиве. Далее через пробел (или новую строку) подаются значения элементов. 


#include <stdio.h>

void insertionSort(int array[], int size) {
	int i, j, key;
	for (i = 1; i < size; i++) {
    	key = array[i];
    	j = i - 1;

    	while (j >= 0 && array[j] > key) {
        	array[j + 1] = array[j];
        	j = j - 1;
    	}
    	array[j + 1] = key;
	}
}

int main() {
	int N;

	printf("Введите количество элементов в массиве: ");
	scanf("%d", &N);

	int array[100];
	int i;

	printf("Введите значения элементов массива через пробел или новую строку: ");
	for (i = 0; i < N; i++) {
    	scanf("%d", &array[i]);
	}

	insertionSort(array, N);

	printf("Отсортированный массив: ");
	for (i = 0; i < N; i++) {
    	printf("%d ", array[i]);
	}
	printf("\n");
	return 0;
}



8.11 Реализовать алгоритм сортировки методом пузырька для целых чисел. Программа предназначена для сортировки массивов, размер которых не превышает 100 элементов.
На вход поступает число N элементов в сортируемом массиве. Далее через пробел (или новую строку) подаются значения элементов. 

#include <stdio.h>

void bubbleSort(int array[], int size) {
	int i, j;
	for (i = 0; i < size - 1; i++) {
    	for (j = 0; j < size - i - 1; j++) {
        	if (array[j] > array[j + 1]) {
            	// Обмен значениями
            	int temp = array[j];
            	array[j] = array[j + 1];
            	array[j + 1] = temp;
        	}
    	}
	}
}

int main() {
	int N;

	printf("Введите количество элементов в массиве: ");
	scanf("%d", &N);

	int array[100];
	int i;

	printf("Введите значения элементов массива через пробел или новую строку: ");
	for (i = 0; i < N; i++) {
    	scanf("%d", &array[i]);
	}

	bubbleSort(array, N);

	printf("Отсортированный массив: ");
	for (i = 0; i < N; i++) {
    	printf("%d ", array[i]);
	}
	printf("\n");

	return 0;
}


