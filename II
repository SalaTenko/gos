Архитектура ЭВМ

1. История вычислительной техники (механические и электромеханические ВМ)
Механический этап. Начался в середине XVII и длился почти до конца XIX столетия. Уровень развития науки в этот период сделал возможным создание механических устройств, выполняющих основные арифметические действия и автоматически запоминающих старшие разряды. 
Электромеханический этап – самый короткий из всех, какие объединяет история развития вычислительной техники. Он длился всего около 60 лет. Это промежуток между изобретением в 1887 году первого табулятора до 1946 года, когда возникла самая первая ЭВМ (ENIAC). Новые машины, действие которых основывалось на электроприводе и электрическом реле, позволяли производить вычисления со значительно большей скоростью и точностью, однако процессом счёта по-прежнему должен был управлять человек.









2. Поколения ЭВМ.


Первое поколение ЭВМ (1948–1958) создавалось на основе вакуумных электроламп, машина управлялась с пульта и перфокарт с использованием машинных кодов. Эти ЭВМ размещались в нескольких больших металлических шкафах, занимавших целые залы.

Элементной базой машин этого поколения были электронные лампы – диоды и триоды. Машины предназначались для решения сравнительно несложных научно-технических задач. К этому поколению ЭВМ можно отнести: МЭСМ, БЭСМ-1, М-1, М-2, М-З, «Стрела», Минск-1, Урал-1, Урал-2, Урал-3, М-20, «Сетунь», БЭСМ-2, «Раздан» (рис. 2.1).

ЭВМ первого поколения были значительных размеров, потребляли большую мощность, имели невысокую надежность работы и слабое программное обеспечение. Быстродействие их не превышало 2–3 тысячи операций в секунду, емкость оперативной памяти – 2 кб или 2048 машинных слов (1 кб = 1024) длиной 48 двоичных знаков.

Второе поколение ЭВМ (1959–1967) появилось в 60-е гг. ХХ века. Элементы ЭВМ выполнялись на основе полупроводниковых транзисторов (рис. 2.2, 2.3). Эти машины обрабатывали информацию под управлением программ на языке Ассемблер. Ввод данных и программ осуществлялся с перфокарт и перфолент.

Элементной базой машин этого поколения были полупроводниковые приборы. Машины предназначались для решения различных трудоемких научно-технических задач, а также для управления технологическими процессами в производстве. Появление полупроводниковых элементов в электронных схемах существенно увеличило емкость оперативной памяти, надежность и быстродействие ЭВМ. Уменьшились размеры, масса и потребляемая мощность. С появлением машин второго поколения значительно расширилась сфера использования электронной вычислительной техники, главным образом за счет развития ПО.

Третье поколение ЭВМ (1968–1973). Элементная база ЭВМ – малые интегральные схемы (МИС), содержавшие на одной пластинке сотни или тысячи транзисторов. Управление работой этих машин происходило с алфавитно-цифровых терминалов. Для управления использовались языки высокого уровня и Ассемблер. Данные и программы вводились как с терминала, так и с перфокарт и перфолент. Машины предназначались для широкого использования в различных областях науки и техники (проведение расчетов, управление производством, подвижными объектами и др.). Благодаря интегральным схемам удалось существенно улучшить технико-эксплуатационные характеристики ЭВМ и резко снизить цены на аппаратное обеспечение. Например, машины третьего поколения по сравнению с машинами второго поколения имеют больший объем оперативной памяти, увеличенное быстродействие, повышенную надежность, а потребляемая мощность, занимаемая площадь и масса уменьшились.

Четвертое поколение ЭВМ (1974–1982). Элементная база ЭВМ – большие интегральные схемы (БИС). Наиболее яркие представители четвертого поколения ЭВМ – персональные компьютеры (ПК). Связь с пользователем осуществлялась посредством цветного графического дисплея с применением языков высокого уровня.

Машины предназначались для резкого повышения производительности труда в науке, производстве, управлении, здравоохранении, обслуживании и быту. Высокая степень интеграции способствовала увеличению плотности компоновки электронной аппаратуры, повышению ее надежности, что привело к увеличению быстродействия ЭВМ и снижению ее стоимости. Все это оказывает существенное воздействие на логическую структуру (архитектуру) ЭВМ и на ее ПО. Более тесной становится связь структуры машины и ее программного обеспечения, особенно операционной системы (ОС) (или монитора) – набора программ, которые организуют непрерывную работу машины без вмешательства человека

Пятое поколение ЭВМ (1990 – настоящее время) создано на основе сверхбольших интегральных схем (СБИС), которые отличаются колоссальной плотностью размещения логических элементов на кристалле.









3. Структура ЭВМ Фон Неймана

Первые компьютерные системы имели заданный набор программ. Изменение встроенной программы требовало практически полной их переделки, что требовало огромного объёма ручной работы по подготовке новой документации, перекоммутации и перестройки блоков и устройств и т. п.
В 1946 г. Был предложен принцип совместного хранения программ и данных в памяти компьютера. При этом память физически отделялась от процессора.

Принципы фон Неймана:

Принцип двоичного кодирования.



Принцип однородности памяти.



Принцип адресуемости памяти.


Принцип последовательного программного управления.


Принцип жесткости архитектуры


4. Количественные характеристики производительности

Количественные характеристики вычислительных систем и компьютерных сетей представляют собой совокупность показателей эффективности (качества), описывающих процессы обработки и передачи данных.
Количественные характеристики можно разделить на две группы:

• глобальные, определяющие наиболее важные свойства системы как целостного объекта;
• локальные, определяющие свойства отдельных устройств или частей системы и позволяющие получить более детальное представление о качестве функционирования системы.

Часто локальные характеристики входят в состав математических выражений для расчета глобальных характеристик.

К глобальным характеристикам относятся:

• характеристики производительности;
• характеристики оперативности;
• характеристики надежности;
• экономические (стоимостные) характеристики;
• прочие характеристики (энергопотребления, массогабаритные и т.д.).

5. Типы архитектур вычислительных систем

Архитектурой компьютера называется его описание на некотором общем уровне, включающее описание пользовательских возможностей программирования, системы команд, системы адресации, организации памяти и т. д. Архитектура определяет принципы действия, информационные связи и взаимное соединение основных логических узлов компьютера: процессора, оперативного ЗУ, внешних ЗУ и периферийных устройств.

Наиболее распространены следующие архитектурные решения.

1. Классическая архитектура (архитектура Дж. фон Неймана) — одно АЛУ.
2. Многопроцессорная архитектура. Наличие в компьютере нескольких процессоров означает, что параллельно может быть организовано много потоков данных и команд, т. е. могут выполняться несколько фрагментов одной задачи.
3. Многомашинная вычислительная система. Несколько процессоров, входящих в вычислительную систему, не имеют общей оперативной памяти, а каждый имеет свою локальную. Каждый компьютер в многомашинной системе имеет классическую архитектуру, и такая система применяется достаточно широко. Однако эффект от применения многомашинной системы может быть получен только при решении задач, имеющих специальную структуру, которая должна разбиваться на столько слабосвязанных подзадач, сколько компьютеров в системе.

6. Характеристики памяти ЭВМ





7. Форматы машинных команд

Машинная команда представляет собой код, определяющий операцию вычислительной машины и данные, участвующие в операции. Команда должна содержать в явной или неявной форме информацию об адресе результата операции, и об адресе следующей команды.
По характеру выполняемых операций различают следующие основные группы команд:
арифметические операции над числами с фиксированной или плавающей точкой;
команды двоично-десятичной арифметики;
логические (поразрядные) операции;
пересылка операндов;
операции ввода-вывода;
передача управления;
управление работой центрального процессора.
Машинная команда состоит из операционной и адресной частей. Эти части могут состоять из нескольких полей. В общем виде машинная команда имеет следующую структуру:

Операционная часть содержит код, задающий вид операции (сложение, умножение, передача и т.д.).
Адресная часть содержит информацию об адресах операндов, результата операции и следующей команды.
Структура команды определяется составом, назначением и расположением полей в команде.
Формат команды – это структура команды с разметкой номеров разрядов, определяющих границы отдельных полей команды.

 
Возможные структуры машинных команд
Четырехадресная структура

содержит наиболее полную информацию о выполняемой операции, включает поле кода операции и четыре адреса для указания ячеек памяти двух операндов, ячейки результата операции, и ячейки, содержащей адрес следующей команды. Такой порядок выборки команд называется принудительным. Он использовался в первых моделях вычислительных машин, имеющих небольшое число команд и очень незначительный объем ОП, поскольку длина такой команды зависит от разрядности адресов операндов и результата.

Трехадресная структура

используется в вычислительных машинах, построенных так, что после выполнения команды по адресу K (команда занимает L ячеек памяти) выполняется команда по адресу K+L. Такой порядок выборки команд называется естественным. Он нарушается только специальными командами передачи управления. При естественном порядке выборки адрес следующей команды формируется в устройстве, называемом счетчик адреса команд. В этом случае команда становится трехадресной.

Двухадресная структура

используется в вычислительных машинах, построенных так, что результат операции будет всегда помещаться в фиксированный регистр процессора, например на место первого операнда. В этом случае адрес результата может явно не указываться.

Одноадресная структура

подразумеваемые адреса имеют результат операции и один из операндов. При этом один из операндов и результат операции размещаются в одном фиксированном регистре. Выделенный для этой цели внутренний регистр процессора получил название аккумулятор. Адрес другого операнда указывается в команде.

Безадресная структура фиксирует адреса обоих операндов и результата операции, например при работе со стековой памятью.

Обычно в вычислительной машине используется несколько форматов команд разной длины (чаще всего безадресные, одноадресные и двухадресные).

8. Способы адресации памяти

Способ адресации
В адресном поле команды содержится командный (исполнительный) адрес
Команда выбирается по физическому адресу
Способ адресации — алгоритм получения физического адреса по командному


Классификация способов адресации
Явные — в адресном поле имеется командный адрес
Неявные — отсутствует адрес

Способы адресации. Явные

1. Непосредственная адресация: операнд (байт или слово) размещается
непосредственно в коде команды
2. Прямая адресация: физический адрес совпадает с командным
3. Косвенная адресация: командный адрес содержит адрес ячейки памяти или
регистра где содержится операнд
4. Автоинкрементная: после выполнения операции с данными адрес операнда
увеличивается на 1, если операнд имеет формат "байт", или на 2, если операнд
имеет формат “слово”
5. Базовая адресация: физический адрес является суммой базового и командного
адресов
6. Базово-индексная адресация: физический адрес является суммой базового,
индексного и командного адресов
7. Укороченная адресация: адресный код содержит часть физического адреса,
другая часть подразумевается
8. Регистровая адресация: адресный код содержит номер регистра
9. Стековая адресация: указывается вершина стека

Способы адресации. Неявные

1. Подразумевается операнд
2. Подразумевается адрес операнда или приемника результата

9. RISC и CISC процессоры

В общем случае процессор — это мозг компьютера. Он читает инструкции из памяти, которые указывают, что делать компьютеру.
Инструкции — это просто числа, которые интерпретируются специальным образом

Архитектура CISC
CISC — COMPLEX INSTRUCTION SET COMPUTER (РАСШИРЕННЫЙ НАБОР КОМАНД)
Отличительные особенности:
• большой набор команд
• использует переменные диапазоны форматов от 16-64 бит на инструкцию
• использует много способов адресации от 12 до 24
• архитектура использует 8-24 регистров общего назначения (мало)
• использует механизм памяти к памяти для выполнения операций
• использует унифицированный кеш для данных и инструкций
• имеет микрокодирование и использует управляющую память (ПЗУ)

Архитектура RISC
RISC - REDUCED INSTRUCTION SET COMPUTER (СОКРАЩЕННЫЙ НАБОР КОМАНД)
Отличительные особенности:
• малый набор команд
• фиксированный формат машинной команды (32 бита)
• использует один такт на команду и режим ограниченной адресации (т.е. 3-5)
• число регистров общего назначения колеблется от 32 до 192 (большое)
• основные операции в процессоре выполняются над содержимым регистров
• имеет разделенный дизайн данных и кеш инструкций
• большая часть управления процессором является аппаратной

10. Устройство управления с жестким и микропрограммным управлением

Управляющее устройство с жесткой логикой (аппаратный тип) – представляет собой совокупность логических схем, вырабатывающих распределенные во времени функциональные управляющие сигналы. Изменить логику работы у таких управляющих автоматов можно, только переделав схему. Множество состояний таких управляющих автоматов задается набором запоминающих элементов (ячеек памяти), а функции переходов и выходов – реализуются набором логических элементов. При синтезе таких управляющих автоматов применяются законы алгебры логики. Синтез комбинационной схемы (КС) автомата происходит в несколько этапов.
• построение таблицы истинности;
• построение функций переходов и выходов;
• минимизация функций переходов и выходов;
• построение схемы в требуемом элементном базисе.

В управляющих автоматах с микропрограммной логикой каждой выполняемой машинной операции ставится в соответствие совокупность хранимых в памяти слов – микрокоманд.
Последовательность микрокоманд образует микропрограмму, хранимую в специальной памяти микропрограмм. Каждая микропрограмма состоит из определенной последовательности микрокоманд, которые после выборки из памяти преобразуются в набор управляющих сигналов.
В таких автоматах блок управления операциями (БУО) выполняет функцию блока хранения и выборки кодов микрокоманд. В машинном такте производится выборка требуемой микрокоманды, выдача сигналов микроопераций, формирование адреса следующей микрокоманды.
Микрокоманда содержит операционную и адресную части. Операционная часть микрокоманды содержит информацию о микрооперациях, выполняемых в различных блоках ЭВМ в течение одного машинного такта под управлением данной микрокоманды. В адресной части микрокоманды находится информация, необходимая для формирования адреса следующей микрокоманды.

Существуют различные способы организации операционной части микрокоманды:
• горизонтальное микропрограммирование;
• вертикальное микропрограммирование;
• смешанное микропрограммирование.

При горизонтальном микропрограммировании, каждому разряду операционной части микрокоманды ставится в соответствие один управляющий сигнал, под действием которого выполняется соответствующая микрооперация.
В случае вертикального микропрограммирования из операционной части микрокоманды считывается двоичный код, равный номеру управляющей точки (код микрооперации) в которую необходимо послать управляющий сигнал. 
С целью уменьшения длины операционной части микрокоманды может применяться косвенное кодирование микрооперации: в операционную часть микрокоманды с этой целью вводят дополнительные поля, содержимое которых может изменять коды микрооперации основных полей, то есть выходы дешифратора дополнительных полей используются для управления дешифратором основных полей. Косвенное кодирование уменьшает длину микрокоманды, но снижает быстродействие из-за потери времени на дешифрацию дополнительных полей.
Существуют два вида адресации микрокоманд:
• принудительная адресация;
• естественная адресация.

При естественной адресации адрес следующей микрокоманды принимается равным увеличенному на единицу адресу предыдущей микрокоманды. В этом случае отпадает необходимость во введении адресной части в каждую микрокоманды. Если микрокоманды идут в естественном порядке, то процесс адресации реализуется счетчиком адреса микрокоманды. Для организации безусловных или условных переходов в микропрограмму включаются дополнительные управляющие микрокоманды.
Принудительная адресация микрокоманды заключается в том, что в каждой микрокоманде указывается адрес следующей микрокоманды. Адрес следующей микрокоманды может задаваться безусловно, независимо от значений признаков (осведомительных сигналов, отображающих текущее состояние операционных блоков процессора) или выбираться по условию, определяемому текущими значениями осведомительных сигналов. Для этого в адресную часть МК кроме адресных полей включаются поля для задания условий (осведомительных сигналов).

В общем случае УУ формирует управляющие сигналы для выполнения следующих функций:
• выборка из основной памяти (ОЗУ или ПЗУ) кода очередной команды;
• расшифровка кода операции и признаков выбранной команды;
• формирование исполнительного адреса операнда;
• выборка операндов и выполнение машинной операции;
• анализ запросов на прерывание исполняемой программы;
• формирование адреса следующей команды

МИКРООПЕРАЦИИ — ЭЛЕМЕНТАРНЫЕ ДЕЙСТВИЯ, ТРЕБУЕМЫЕ ДЛЯ
ВЫПОЛНЕНИЯ МАШИННОЙ КОМАНДЫ
Операции:
• передача информации из одного регистра в другой
• выполнение элементарных сдвигов в рамках одного регистра
• проверка бита в регистре
• передача данных из регистра в шины и т.д.
Цикл команды включает один или несколько машинных циклов.

11. Методы обмена информацией между МП (микропроцессором) и внешними устройствами



12. Внутренняя структура микропроцессора 8086


13. Назначение входов микропроцессора 8086

Входы процессора
CLK — вход тактовых импульсов, задающих частоту процессора
NMI — немаскируемые запросы на прерывания
INTR — вход маскируемых запросов на прерывания
RESET —аппаратный сброс процессора
READY — готовность внешнего устройства или памяти к обмену данными
TEST — входной сигнал проверки. Используется в сочетании с сопроцессорами
MN/MX — задает режим работы процессора
HOLD — вход запроса на прямой доступ к памяти
+5 — питание (+5В)
GND — заземление (отрицательный контакт питания)

14. Назначение выходов микропроцессора 8086

AD0-AD15 — совмещенная шина адреса и данных
A16-A19 — старшие разряды шины адреса
BHE — для разрешения подключения старшего банка памяти (16 или 8)
RD — чтение из памяти или внешнего устройства
WR — запись в порт внешнего устройства или в память
DT/R — 1 - передача данных, 0 - прием
INTA — для подтверждения обработки запроса на прерывание
HLDA — выход подтверждения запроса на прямой доступ к памяти
DEN — по совмещенной шине передаются данные
ALE — при выставлении адреса на шину формируется стробирующий импульс
M/IO — разделение адресных пространств памяти и внешних устройств

15. Конвейерные вычисления, общие понятия

Конвейер — способ организации вычислений, используемый в современных процессорах и контроллерах с целью повышения их производительности (увеличения числа инструкций, выполняемых в единицу времени), технология, используемая при разработке компьютеров и других цифровых электронных устройств

Идея заключается в разделении обработки компьютерной инструкции на последовательность независимых стадий с сохранением результатов в конце каждой стадии. 
Это позволяет управляющим цепям процессора получать инструкции со скоростью самой медленной стадии обработки, однако при этом намного быстрее, чем при выполнении эксклюзивной полной обработки каждой инструкции от начала до конца.



16. Конвейер команд

Цикл команды представляет собой последовательность этапов. Возложив реализацию каждого из них на самостоятельное устройство и последо­вательно соединив такие устройства, мы получим классическую схему конвейера команд. Выде­лим в цикле команды шесть этапов:

Выборка команды (ВК). Чтение очередной команды из памяти и занесение ее в регистр команды.
Декодирование команды (ДК). Определение кода операции и способов адреса­ции операндов.
Вычисление адресов операндов (ВА). Вычисление исполнительных адресов каждого из операндов в соответствии с указанным в команде способом их адре­сации.
Выборка операндов (ВО). Извлечение операндов из памяти. Эта операция не нужна для операндов, находящихся в регистрах.
Исполнение команды (ИК). Исполнение указанной операции.
Запись результата (ЗР). Занесение результата в память.

17. Конфликты в конвейере

Конфликты - это такие ситуации в конвейерной обработке, которые препятствуют выполнению очередной команды в предназначенном для нее такте.

Конфликтные ситуации в конвейере принято обозначать термином риск(hazard), а обусловлены они могут быть тремя причинами:
Попыткой нескольких команд одновременно обратиться к одному и тому же ресурсу ВМ(структурный риск);
Взаимосвязью команд по данным(риск по данным);
Неоднозначностью при выборке следующей команды в случае команд перехода(риск по управлению);

Структурные конфликты
Структурные конфликты возникают в том случае, когда аппаратные средства процессора не могут поддерживать все возможные комбинации команд в режиме одновременного выполнения с совмещением.

Причины структурных конфликтов

Не полностью конвейерная структура процессора. При этом некоторые ступени отдельных команд выполняются более одного такта.
Если какой-то блок конвейера вносит задержку, то тормозится работа всего конвейера. Образуемый при этом «пузырь» должен пройти от места своего возникновения до самого конца конвейера . Таким образом, скорость конвейера определяется скоростью самой медленной его ступени.

Эту ситуацию можно было бы улучшить двумя способами.

Первый способ предполагает увеличение времени такта до такой величины, которая позволила бы все этапы любой команды выполнять за один такт, как это и предполагается согласно основной концепции конвейерной обработки. Однако при этом существенно снижается эффект от конвейерной обработки, так как все этапы всех команд будут выполняться значительно дольше, в то время как обычно нескольких тактов требует выполнение лишь отдельных этапов очень небольшого числа команд.
Второй способ предполагает использование таких аппаратных решений, которые позволили бы значительно снизить затраты времени на выполнение действия, приводящего к появлению «пузырей» (например, использовать матричные схемы умножения). Но это приведет к усложнению схемы процессора. 
Недостаточное дублирование некоторых ресурсов. Одним из типичных примеров таких конфликтов служит конфликт из-за доступа к запоминающим устройствам.
Борьба с конфликтами такого рода проводится путем увеличения числа однотипных функциональных устройств, которые могут одновременно выполнять одни и те же или схожие функции.
В качестве еще одного подхода к решению проблемы конфликтов при обращении к ЗУ следует привести использование многопортового доступа к регистровой памяти, при котором к регистрам можно одновременно обращаться по нескольким каналам для записи и считывания информации.

Конфликты по управлению
Конфликты по управлению возникают при конвейеризации команд переходов и других команд, изменяющих значение счетчика команд.

Простейший случай разрешения этой ситуации — использование так называемого метода выжидания. Он заключается в замораживании операций в конвейере путем блокировки выполнения любой команды, следующей за командой условного перехода, до тех пор, пока не станет известным направление перехода. Привлекательность такого решения заключается в его простоте. Главный недостаток — резкое уменьшение преимуществ конвейерной обработки. 

Конфликты по данным
Конфликты по данным возникают в случаях, когда выполнение одной команды зависит от результата выполнения предыдущей команды.

Конфликты типа RAW (Read After Write): команда j пытается прочитать операнд прежде, чем команда / запишет на это место свой результат. При этом команда j может получить некорректное (старое) значение операнда.

Уменьшение влияния конфликта типа RAW обеспечивается методом, который называется пересылкой или продвижением данных (data forwarding), обходом (data bypassing), иногда закорачиванием (short- circuiting). В этом случае результаты, полученные на выходах исполнительных устройств, помимо входов приемника результата передаются также на входы всех исполнительных устройств микропроцессора

Если устройство управления обнаруживает, что полученный какой- либо командой результат требуется одной из последующих команд в качестве операнда, то он сразу же, параллельно с записью в приемник результата, передается на вход исполнительного устройства для использования следующей командой.

Главной причиной двух других типов конфликтов по данным является возможность неупорядоченного выполнения команд в современных микропроцессорах, то есть выполнение команд не в том порядке, в котором они записаны в программе (ложные взаимозависимости).

Конфликты типа WAR (Write After Read): команда j пытается записать результат в приемник, прежде чем он считается оттуда командой /. При этом команда i может получить некорректное новое значение операнда

Конфликты типа WAW (Write After Write): команда j пытается записать результат в приемник, прежде чем в этот же приемник будет записан результат выполнения команды /, то есть запись заканчивается в неверном порядке, оставляя в приемнике результата значение, записанное командой /
Устранение конфликтов по данным типов WAR и ^^достигается путем отказа от неупорядоченного исполнения команд, но чаще всего — путем введения буфера восстановления последовательности команд.

18. Совмещение и разделение адресных пространств памяти и портов внешних устройств

Адресное пространство ввода/вывода может быть совмещено с адресным про­странством памяти или быть выделенным. 

Достоинства совмещенного адресного пространства:

расширение набора команд для обращения к внешним устройствам, что позво­ляет сократить длину программы и повысить быстродействие;
значительное увеличение количества подключаемых внешних устройств;
возможность вне процессорного обмена данными между внешними устройства­ми, если в системе команд есть команды пересылки между ячейками памяти; возможность обмена информацией не только с аккумулятором, но и с любым регистром центрального процессора.

Недостатки совмещенного адресного пространства:

сокращение области адресного пространства памяти;
усложнение декодирующих схем адресов в СВВ (системе ввода/вывода);
трудности распознавания операций передачи информации при вводе/выводе среди других операций. Сложности в чтении и отладке программы, в которой простые команды вызывают выполнение сложных операций ввода/вывода;
трудности при построении СВВ на простых модулях ввода/вывода: сигналы управления не смогут координировать сложную процедуру ввода/вывода. По­этому МВВ (модули ввода/вывода) часто должны генерировать дополнительные сигналы под управ­лением программы.

Достоинства выделенного адресного пространства:

адрес внешнего устройства в команде ввода/вывода может быть коротким. В большинстве СВВ количество внешних устройств намного меньше количе­ства ячеек памяти. Короткий адрес ВУ (внешнего устройства) подразумевает такие же короткие ко­манды ввода/вывода и простые дешифраторы;
программы становятся более наглядными, так как операции ввода/вывода вы­полняются с помощью специальных команд;
разработка СВВ может проводиться отдельно от разработки памяти

Недостатки выделенного адресного пространства: 
ввод/вывод производится только через аккумулятор центрального процессо­ра. Для передачи информации от ВУ (внешнего устройства) в РОН (регистры общего назначения), если аккумулятор занят, требуется выполнение четырех команд (сохранение содержимого аккумулятора, ввод из ВУ, пересылка из аккумулятора в РОН, восстановление содержимого аккумулятора);
перед обработкой содержимого ВУ это содержимое нужно переслать в ЦП (центральный процессор).

19. Иерархическая организация памяти ЭВМ



Упрощенно память делят на внутреннюю и внешнюю. Применительно к персональному компьютеру их можно определить так:
внутренняя память — электронная (полупроводниковая) память, устанавливаемая на системной плате или на платах расширения;
внешняя память — память, реализованная в виде устройств с различными принципами хранения информации и обычно с подвижными носителями. Сюда входят устройства магнитной (дисковой и ленточной) памяти, оптической и магнитооптической памяти.
Для процессора непосредственно доступна внутренняя память, доступ к которой осуществляется по адресу, заданному программой. Для внутренней памяти характерен одномерный (линейный) адрес. Внутренняя память подразделяется на оперативную, информация в которой может изменяться процессором в любой момент времени, и постоянную, информацию которой процессор может только считывать. Обращение к ячейкам оперативной памяти может происходить в любом порядке (как по чтению, так и по записи), и оперативную память называют памятью с произвольным доступом - Random Access Memory (RAM) - в отличие от постоянной памяти (Read Only Memory,
ROM).

Внешняя память адресуется более сложным образом:
каждая ее ячейка имеет свой адрес внутри некоторого блока, который, в свою очередь, имеет многомерный адрес.
Во время физических операций обмена данными блок может быть считан или записан только целиком. В случае одиночного дискового накопителя адрес блока будет трехмерным: номер поверхности (головки), номер цилиндра и номер сектора. В современных накопителях этот трехмерный адрес часто заменяют линейным номером - логическим адресом блока, а его преобразованием в физический адрес занимается внутренний контроллер накопителя. Поскольку дисковых накопителей в компьютере может быть множество, в адресации дисковой памяти участвует и номер накопителя, а
также номер канала интерфейса. С такой сложной системой адресации процессор справляется только с помощью программного драйвера, в задачу которого входит копирование некоторого блока данных из оперативной памяти в дисковую и обратно. Дисковая память является внешней памятью с прямым доступом, что подразумевает возможность обращения к блокам (но не ячейкам) в произвольном порядке.

Важные параметры подсистемы памяти:
объем хранимой информации. Максимальный объем хранят ленточные и дисковые устройства со сменными носителями, за ними идут дисковые накопители, и затем оперативная память;
время доступа - усредненная задержка начала обмена полезной информацией относительно появления запроса на данные. Минимальное время доступа имеет оперативная память, за ней идет дисковая и после нее - ленточная.
скорость обмена при передаче потока данных (после задержки на время доступа). Максимальную скорость обмена имеет оперативная память, за ней идет дисковая и после нее - ленточная.
удельная стоимость хранения единицы данных - цена накопителя (с носителями), отнесенная к единице хранения (байту или мегабайту). Минимальную стоимость хранения имеют ленточные устройства со сменными носителями, их догоняют дисковые накопители, а самая дорогая оперативная память.

Внутренняя и внешняя память используются различными способами.
Внутренняя (оперативная и постоянная) память является хранилищем программного кода, который непосредственно может быть исполнен процессором. В ней же хранятся и данные, также непосредственно доступные процессору (а, следовательно, и исполняемой программе).
Внешняя память обычно используется для хранения файлов, содержимое которых может быть произвольным. Процессор (программа) имеет доступ к содержимому файлов только опосредованно через отображение их (полное или частичное) в некоторой области оперативной памяти.

20. Шины ЭВМ

Шинная организация ЭВМ
Шина – совокупность линий, идущих параллельно и имеющих одинаковое функциональное назначение
Шина данных предназначена для пересылки кодов обрабатываемых данных, а также машинных кодов команд между устройствами ЭВМ
Шина адреса несет адрес ячейки памяти или порта ввода-вывода, который взаимодействует с микропроцессором
Шина управления несет сигналы управления, обеспечивающие правильное взаимодействие блоков ЭВМ друг с другом и с внешней средой

По способам передачи:

параллельные (данные переносятся потактово словами: каждый бит — отдельным проводником)
последовательные (биты данных переносятся поочередно по каналу, например, паре проводников)

21. Что такое ЭВМ? Персональный компьютер? Зачем нужна материнская плата? Зачем используется блок питания? Корпус? Что такое набор микросхем системной логики? Что такое форм-фактор? Сколько шин в персональном компьютере? Зачем они нужны? Как определить пропускную способность шины? Виды памяти? Статическая и динамическая память? Что такое интерфейс? Какие интерфейсы используются в ПК?

ЭВМ (электронно-вычислительная машина) - это комплекс технических и программных средств, предназначенные для автоматизации подготовки и решения задач пользователей.

Персональный компьютер - однопользовательская (предназначенная для использования одним пользователем) ЭВМ, имеющая эксплуатационные характеристики бытового прибора и универсальные функциональные возможности. ПК может быть стационарным (чаще всего настольным) или портативным (лептоп, планшет).

Зачем нужна материнская плата (МП)? 

МП связывает между собой комплектующие ПК. Создает из оборудования единую систему.

Объединение. На системную плату устанавливается: процессор, ОЗУ, видеокарта, жесткий диск. Присутствуют разъемы питания. Все это соединяется на одной плате.
Подключение периферии. К компьютеру подключаются клавиатура, принтер, мышь. Разъем преобразует это оборудование в единую систему, которая помогает выполнять функции ввода-вывода информации.
Связь CPU с комплектующими. Устанавливается в специальное гнездо (Socket). Сверху крепится охлаждение — вентилятор. Поэтому при выборе CPU убедитесь, что он встанет в гнездо.
Вывод изображения. Если дисплей подключается через материнскую плату, тогда она отвечает за вывод изображения. Новые материнки оснащаются видео интерфейсами DVI, DisplayPort или HDMI.
Передача звука. На материнках часто устанавливаются встроенные звуковые карты. По качеству они не сравнятся с дискретными, но обеспечивают хорошую передачу звука. Подключите дополнительно к ним наушники, микрофон..
Работа в интернет. Практически на каждой плате установлен встроенный сетевой адаптер. Служит для связи роутера с модемом при помощи Lan-кабеля. Модели среднего и высокого ценового класса оснащены встроенным Wi-Fi модулем, обеспечивающим беспроводное соединение.

Зачем используется блок питания?

Блок питания настольного компьютера преобразует переменный ток (AC) от настенной розетки сетевого электричества в низковольтный постоянный ток (DC) для работы материнской платы, процессора и периферийных устройств.

Зачем используется корпус компьютера?
5 важных функций:
Защита от механических повреждений. Корпус защищает комплектующие от воздействия с внешней среды. 
Защита от пыли. Чем больше грязи в компьютере, тем больше шанс перегреть комплектующие компьютера, которые в свою очередь могут выйти из строя.
Снижение уровня шума от компьютера. В любом корпусе звук от компьютера будет тише, ежели без корпуса. Тем более корпус можно поставить под стол или отодвинуть подальше, что бы его вообще не было слышно.
Поддержка оптимальной температуры комплектующих компьютера. Если в корпусе не будет нормальных воздушных потоков, то теплый воздух будет концентрироваться внутри корпуса и тем самым, он будет нагревать процессор и видеокарту, что тоже приведет к перегреву и выхода этих комплектующих из строя.
Красивый внешний вид

Что такое набор микросхем системной логики? (чипсет)
Набор системной логики (англ. chipset) — набор микросхем, обеспечивающих подключение ЦПУ (центральное процессорное устройство)  к ОЗУ (оперативная память) и контроллерам периферийных устройств.

Форм-фактор (от англ. form factor) или типоразмер — стандарт, задающий габаритные размеры технического изделия, а также описывающий дополнительные совокупности его технических параметров, например форму, типы дополнительных элементов, размещаемых в/на устройстве, их положение и ориентацию.
Форм-фактор (как и любые другие стандарты) носит рекомендательный характер.

Сколько шин в персональном компьютере? Зачем они нужны?

Основных шин три: шина данных, адресная шина и командная шина. По способу передачи данных шины делятся на последовательные и параллельные. Последовательные шины передают данные по одному проводнику, один бит за один раз, в параллельных шинах передача данных разделена между несколькими проводниками и поэтому можно передать большее количество данных.

Системная шина (магистраль) – это набор электронных линий, связывающих воедино центральный процессор, системную память и периферийные устройства. 
Системная шина состоит:
шина данных ( для передачи данных); 
шина адреса ( для передачи адресов устройств, которым передаются данные);
шина управления ( для передачи управляющих сигналов, синхронизирующих работу разных устройств).

Как определить пропускную способность шины? 
Термин «пропускная способность» определяет количество данных, передаваемых шиной за единицу времени. Пропускная способность измеряется в мегабайтах в секунду (Мбайт/с) или в мегабитах в секунду (Мбит/с). Здесь важно не путать эти два значения, поскольку скорость в мегабайтах в восемь раз больше скорости в мегабитах (1 байт = 8 бит).
Для определения скорости передачи данных по шине процессора необходимо умножить разрядность шины данных (64 бит, или 8 байт, для Celeron/Pentium III/4 или Athlon/Duron/ Athlon XP/Athlon 64) на тактовую частоту шины (она равна базовой (внешней) тактовой частоте процессора).

Виды памяти? 

Внутренняя память:
Кэш-память - сверхоперативная память запоминающего устройства, позволяющая увеличить быстродействие компьютера.
ПЗУ - постоянное запоминающее устройство (энергонезависимая память только для чтения информации. Данный вид памяти используется для хранения только такой информации, которая обычно не меняется в ходе эксплуатации компьютера. Типичным примером использования ПЗУ является хранение в нем базового программного обеспечения, используемого при загрузке компьютера (BIOS). Микросхемы ПЗУ располагаются на материнской плате.).
ОЗУ - оперативное запоминающее устройство (энергозависимая память для чтения и записи информации, применяемая для временного хранения команд и данных, необходимых процессору для выполнения текущих операций.).

Внешняя память (устройства для хранения информации методом магнитной / оптической записи). Оперативная память изготавливается в виде небольших печатных плат с рядами контактов, на которых размещаются интегральные схемы памяти.
Жесткие диски (винчестеры)
CD/DVD диски

Статическая и динамическая память? 
Статическая память (англ. static storage) — энергозависимая память, которой для хранения информации достаточно сохранения питающего напряжения; — Динамическая память (англ. dynamic storage) — энергозависимая память, в которой информация хранится только в течение достаточно короткого промежутка времени, после которого информацию нужно восстанавливать заново, иначе она будет потеряна.

Что такое интерфейс?
Связь устройств ЭВМ друг с другом осуществляется с помощью сопряжений, которые в вычислительной технике называются интерфейсами. Интерфейс - представляет собой совокупность линий и шин, сигналов, электронных схем и алгоритмов, предназначенную для осуществления обмена информацией между устройствами.

Какие интерфейсы используются в ПК?
Все интерфейсы по своему расположению делятся на два типа:
внешние;
внутренние.

Внутренние интерфейсы
1. SATA
Это усовершенствованная версия устаревшего ATA. С помощью SATA подключают к материнской плате накопители, например, жесткий диск. Как правило, это внутренний интерфейс, но иногда его выводят наружу.
2. ATA/133 (Parallel ATA, UltraDMA/133 или E-IDE).
Это параллельная шина. Она нужна для передачи сигнала с/на жесткий и съемный диски.
3. AGP.
Специальная шина, с помощью которой подключают видеокарту. 
4. PCI и PCI-x.
Стандартные параллельные шины, с помощью которых подключаются сетевые и звуковые карты, модемы, платы захвата видео.
5. PCIe.
С шинами, описанными в пятом пункте, ее связывает только похожее название. Это не параллельный, а последовательный интерфейс. С помощью него можно подключить графические и другие виды карт. PCIe обеспечивает пропускную способность в два раза выше, чем AGP. Это самая последняя среди шин для графических карт.

Внешние интерфейсы
1. USB разъем.
С помощью разъема Universal Serial Bus можно подключить много дополнительных устройств: клавиатуру, мышь, камеру, принтер. Интерфейс бывает трех видов:
А) «тип А» (расположен в ПК);
Б) «тип Б» (находится на съемном устройстве);
В) mini-USB (цифровые камеры, внешние жесткие диски и др.).

2. «Тюльпан» (Cinch/RCA).
Эти разъемы имеют разное цветовое кодирование в зависимости от типа принимаемого сигнала (звук, видео, яркость и т.д.).
3. PS/2.
Разъемы, которые используются в стационарных компьютерах для подключения мышки и клавиатуры. Им характерно следующее кодирование: зеленый цвет – мышь, фиолетовый – клавиатура. Если их перепутать, ничего страшного не случится, просто подключенные устройства не будут работать. Чтобы исправить ситуацию, достаточно просто поменять вилки местами.
4. DVI.
Слот для монитора, передающий цифровые сигналы.
5. VGA.
С помощью разъема Video Graphics Array подключают монитор. Он предназначен для передачи информации синего, зеленого и красного цветов.
6. RJ45 для LAN и ISDN.
Сетевой порт, использующийся для подключения к Ethernet.
7. RJ11.
Порт, который служит для подключения модема.
8. HDMI.
Это мультимедийный цифровой разъем, который предназначен для сигналов HDTV с максимальным разрешением 1920х1080.
9. SCART.
Это комбинированный разъем, который сочетает такие сигналы: RGB, S-Video и аналоговое стерео.
10. S-Video.
Вилка с 4 контактами принимает сигналы цвета и яркости.

22. Что такое таблица истинности? Булева функция? Как они связаны между собой? Как получить алгебраическую булеву функцию из таблицы истинности? И наоборот? Каким образом можно синтезировать логическую схему по таблице истинности? По алгебраической формуле?

Чтобы математически описать схемы, которые строятся путём сочетания различных вентилей, используется особый тип алгебры, называемой булевой алгеброй, в которой все переменные и функции могут принимать только значения 0 или 1. Название эта алгебра получила в честь английского математика Джорджа Буля.
Как и в обычной алгебре, правила преобразования входных значений в выходные называются функциями, которые могут зависеть от одной или несколько переменных, и получать результат (0 или 1), основываясь только на их значениях. Если функция содержит n переменных, то существует 2n возможных наборов значений функции.
Булева функция может быть представлена двумя способами: в виде таблицы истинности и с помощью алгебраической записи.
Если написать таблицу, в которой перечислить все возможные комбинации входных переменных и соответствующие этим комбинациям значения функций (выходное значение), то получится таблица истинности. Очевидно, что размер таблицы определяется числом переменных в функции и может быть огромным ( 2n , где n - число входных переменных).
Как альтернатива таблицы истинности используется алгебраическая запись, в которой перечисляются все комбинации переменных, дающие единичное (или нулевое) значение функции. При этом знаком «умножить» обозначается операция И, а знаком плюс – операция ИЛИ, черта над переменной означает операцию НЕ. Например, для таблицы истинности вида:

Здесь первое слагаемое образуется из инверсных значений входных переменных, так как единица на выходе соответствует их нулевым значениям, второе слагаемое – из двух инверсных и одного прямого, так как единица на выходе соответствует нулевым значениям двух переменных и единичному значению третьей и т.д.
Схематически вентили НЕ, И-НЕ, ИЛИ-НЕ, И, ИЛИ обозначаются, как показано на рис. 39. Для отличия вентилей И-НЕ и ИЛИ-НЕ от И и НЕ на схемах первых выход обозначается кругом.
Синтез логической схемы осуществляется образом, аналогичным получению булевой функции из таблицы истинности (см. рис. 40). Для каждой строки таблицы истинности (или для каждого слагаемого булевой функции, если схема строится на основе неё) формируется вентиль «И». Все полученные вентили объединяются через вентиль «ИЛИ», в результате чего получается выход схемы.


Рис. 39. Значки для изображения вентилей на схемах и булевы функции, описывающие их работу (сверху вниз – европейское обозначение, российское обозначение, булева функция в виде таблицы истинности)

Рис. 40. Формирование булевой функции и синтез логических схем

23. Что такое система счисления? Чем отличается позиционная система счисления от непозиционной? Как получить качественный эквивалент числа в непозиционной системе счисления? В позиционной? Как перевести числа из двоичной системы счисления в десятичную? Восьмеричную? Шестнадцатеричную? И наоборот?

Для записи чисел человечеством придуманы различные правила, называемые системами счисления. По этим правилам любое число представляется в виде набора специальных символов – цифр (от араб. сифр — нуль, буквально— пустой; арабы этим словом называли знак отсутствия разряда в числе). Получение количественного эквивалента числа осуществляется по алгоритму замещения, согласно которому сначала цифры заменяются их количественными эквивалентами, а затем эквивалент числа получается путем арифметических операций над эквивалентами цифр.
Взависимости от того, меняет ли свое количественное значение цифра при разном положении в числе, системы счисления можно классифицировать на непозиционные и позиционные системы.
В непозиционных системах счисления число образуется из цифр, значение которых не изменяется при различном положении цифр в числе. Примером таких систем служит римская система счисления. ней в качестве цифр для составления чисел используются буквы латинского алфавита, I – означает единицу, V – пять, X – десять, L – пятьдесят, C – сто, D – пятьсот, M – тысяча. Для получения числа требуется просто просуммировать количественные эквиваленты входящих в него цифр, с учетом того, что если младшая цифра идет перед старшей цифрой, то она входит в сумму с отрицательным знаком. Например, DLXXVII = пятьсот + пятьдесят + десять + десять + пять + один + один = пятьсот семьдесят семь. Или CDXXIX = минус сто + пятьсот + десять + десять + минус один + десять = четыреста двадцать девять.
	В позиционных системах счисления количественное значение цифры определяется её позицией в числе. Номер позиции называется разрядом. Число цифр, используемых для представления чисел, называется основанием. 

Для выполнения арифметических операций над числами они должны быть представлены в одной системе счисления.
Перевод чисел из любой системы счисления в десятичную систему осуществляется простым получением их количественных эквивалентов и записи в виде десятичного числа.
Перевод чисел из десятичной системы в любую другую осуществляется путем деления исходного числа на основание требуемой системы и записи остатков от деления в обратном порядке. Например, смотри рис. 17.

Рис. 17. Перевод числа 247 из десятичной системы счисления в двоичную(слева) и восьмеричную (справа) системы


Перевод числа из шестнадцатеричной системы в двоичную систему может быть осуществлен путем представления каждой его цифры в виде двоичной тетрады, и последовательной записи этих тетрад. Например, число FF(16) представляется как 1111 1111(2) . А число 3A(16) , как 0011 1010(2) . 
Соответственно, перевод числа из двоичной системы в шестнадцатеричную систему осуществляется путем деления его на тетрады, и представления каждой тетрады в виде шестнадцатеричной цифры. Например, 10111001(2) , представляется как 1011 1001(2) , и в шестнадцатеричной системе имеет вид B9(16) .
Перевод числа из восьмеричной системы в двоичную систему осуществляется аналогично переводу числа из шестнадцатеричной системы, только цифры заменяются не тетрадами, а двоичными триадами. Например, 77(8) будет представлено как 111 111(2) , а число 10(8) , как 001 000(2) . 
Двоичное число при переводе в восьмеричную систему счисления сначала делится на триады, а затем каждая триада представляется в виде восьмеричной цифры. Например, 11100111(2) , делится на 011 100 111(2) , и получается 347(8) .

Перевод чисел из шестнадцатеричной системы счисления в восьмеричную систему и наоборот осуществляется в два этапа. Сначала исходное число переводится в двоичную или десятичную систему, а затем из двоичной или десятичной системы число переводится в требуемую систему счисления. Например, число FF(16) в двоичной системе имеет вид 1111 1111(2) , и в восьмеричной системе оно примет вид 377(8) .

24. Что такое флаг? Зачем он используется? Каким образом можно манипулировать
флагами? Что такое маска? Что такое двоичнодесятичное число? Какие базовые типы данных используются для хранения переменных в языке СИ?

На практике часто приходится определять или задавать состояние устройств или управлять выполнением программы с использованием двоичных флагов – переменных, в которых может храниться только 0 или 1. Причем флаг считается установленным, если он содержит 1 и не установленным в противном случае. Примером использования флагов можно назвать программное управление выключателями: если необходимо выключатель перевести в состояние «включено», то устанавливаем флаг в 1, в противном случае в 0.
Для манипуляции отдельными битами целых переменных в языке Си используются разрядные операции: И, ИЛИ, НЕ, ИСКЛЮЧАЮЩЕЕ-ИЛИ, СДВИГ ВЛЕВО, СДВИГ ВПРАВО. Операция И обозначается символом &, операция ИЛИ - |, операция НЕ - ~, операция ИСКЛЮЧАЮЩЕЕ ИЛИ - ^, СДВИГ ВЛЕВО - <<, СДВИГ ВПРАВО - >>. Выполнение этих операций происходит в двоичной системе счисления, несмотря на то, в каком виде представлены её операнды. Например, операция 2 & 5 будет равна 0 (т.е. 010 & 101 = 0).

	Чтобы получить значение определённого флага (т.е. располагающегося в определённом разряде числа) необходимо выполнить следующую последовательность действий:

flag = (registr >> (k – 1)) & 0x1,

где registr – это переменная, хранящая флаги, k – номер разряда (по порядку) в котором находится требуемый флаг. В результате этих действий переменная registr будет сдвинута вправо таким образом, что требуемый флаг окажется в первом разряде, после чего будет произведена операция логического умножения на единицу (т.е. все разряды числа, кроме первого, будут умножены на 0). В переменную flag будет помещено либо 1, либо 0, в зависимости от того, в каком состоянии был флаг.

Если требуется установить значение флага в единицу, то необходимо выполнить следующие действия:

registr = registr | (1 << (k – 1)).

Другими словами, необходимо выполнить операцию поразрядного ИЛИ между регистром флагов и числом, в котором в нужном разряде установлена 1, а в остальных разрядах числа содержатся нули.

Если требуется установить значение флага в ноль, то необходимо выполнить следующие действия:

registr = registr & (~(1 << (k – 1))).

Другими словами, необходимо выполнить операцию поразрядного И между регистром флагов и числом, в котором в нужном разряде установлен 0, а в остальных содержатся единицы. Такое число получается путем инвертирования числа, содержащего единицу в том разряде, в котором нам нужен 0. Такая операция называется маскированием, а число, определяющее разряд (второй операнд) – маской. Ясно, что выделение разряда и установка его в ноль выполняется одинаковым образом, с тем лишь отличием, что в первом случае используется маска с единицей в требуемом разряде и остальными разрядами равными нулю, а во втором случае – инверсная ей маска.

Чтобы управлять отдельными битами (например, устанавливать их в 1 или сбрасывать в 0), нам нужен способ идентифицировать конкретные биты, которыми мы хотим манипулировать. К сожалению, побитовые операторы не умеют работать с битовыми позициями. Вместо этого они работают с битовыми масками.
Битовая маска – это предопределенный набор битов, который используется для выбора того, какие конкретные биты будут изменены при последующих операциях.

Что такое двоичнодесятичное число?
Двоично-десятичный код (англ. binary-coded decimal), BCD, 8421-BCD  — форма записи рациональных чисел, когда каждый десятичный разряд числа записывается в виде его четырёхбитного двоичного кода. Таким образом, каждая тетрада двоично-десятичного числа может принимать значения от 00002 (010) до 10012 (910).
Например, десятичное число 31110 будет записано в двоичной системе счисления в двоичном коде как 1 0011 01112, а в двоично-десятичном коде как 0011 0001 0001BCD.

Какие базовые типы данных используются для хранения переменных в языке СИ?
Переменная имеет определенный тип. И этот тип определяет, какие значения может иметь переменная и сколько байт в памяти она будет занимать. В Си определены следующие базовые типы данных:

char: представляет один символ. Занимает в памяти 1 байт (8 бит). Может хранить любое значение из диапазона от -128 до 127
unsigned char: представляет один символ. Занимает в памяти 1 байт (8 бит). Может хранить любой значение из диапазона от 0 до 255
signed char: то же самое, что и char
short: представляет целое число в диапазоне от –32768 до 32767. Занимает в памяти 2 байта (16 бит).
Имеет псевдонимы short int, signed short и signed short int.
unsigned short: представляет целое число в диапазоне от 0 до 65535. Занимает в памяти 2 байта (16 бит).
Имеет псевдоним unsigned short int.
int: представляет целое число. В зависимости от архитектуры процессора может занимать 2 байта (16 бит) или 4 байта (32 бита). Диапазон предельных значений соответственно также может варьироваться от –32768 до 32767 (при 2 байтах) или от −2 147 483 648 до 2 147 483 647 (при 4 байтах).
Имеет псевдонимы signed int и signed
unsigned int: представляет положительное целое число. В зависимости от архитектуры процессора может занимать 2 байта (16 бит) или 4 байта (32 бита), и из-за этого диапазон предельных значений может меняться: от 0 до 65535 (для 2 байт), либо от 0 до 4 294 967 295 (для 4 байт).
Имеет псевдоним unsigned: то же самое, что и unsigned int
long: представляет целое число в диапазоне от -2 147 483 648 до 2 147 483 647. Занимает в памяти 4 байта (32 бита).
Имеет псевдонимы long int, signed long int и signed long.
unsigned long: представляет целое число в диапазоне от 0 до 4 294 967 295. Занимает в памяти 4 байта (32 бита).
Имеет псевдоним unsigned long int.
long long: представляет целое число в диапазоне от -9223372036854775807 до +9 223 372 036 854 775 807. Занимает в памяти, как правило, 8 байт (64 бита).
Имеет псевдонимы long long int, signed long long int и signed long long.
unsigned long long: представляет целое число в диапазоне от 0 до 18 446 744 073 709 551 615. Занимает в памяти, как правило, 8 байт (64 бита).
Имеет псевдоним unsigned long long int.
float: представляет вещественное число одинарной точности с плавающей точкой в диапазоне +/- 3.4E-38 до 3.4E+38. В памяти занимает 4 байта (32 бита)
double: представляет вещественное число двойной точности с плавающей точкой в диапазоне +/- 1.7E-308 до 1.7E+308. В памяти занимает 8 байт (64 бита)
long double: представляет вещественное число двойной точности с плавающей точкой в диапазоне +/- 3.4E-4932 до 1.1E+4932. В памяти занимает 10 байт (80 бит). На некоторых системах может занимать 96 и 128 бит.
void: тип без значения

25. Взаимодействие с устройствами в Linux. Специальные файлы устройств. Функции
open, close, read, write.

Для взаимодействия пользователей с ПК, работающим под управлением операционной системы (ОС) Linux, используется эмуляция нескольких текстовых и графических терминалов. Т.е. другими словами, даже если пользователь сидит непосредственно за ПК, то он как будто работает за терминалом, подключенным к ЭВМ.

В ОС Linux пользователи "изолируются" от аппаратной части персонального компьютера. Для доступа к устройствам используется единый интерфейс в виде специальных файлов устройств, которые связывают приложения с соответствующими драйверами. Вся работа с устройством происходит через этот файл, а соответствующий ему драйвер обеспечивает выполнение операций ввода/вывода согласно конкретным протоколам обмена данными между ЭВМ и устройством. Причем правила работы с файлами устройств такие же, как и правила работы с файлами на запоминающем устройстве, с некоторыми дополнениями, позволяющими выдавать управляющие воздействия.

Все устройства, подключаемые к ЭВМ, условно можно разделить на два класса:

блочные устройства, т.е. передающие и принимающие данные большими фрагментами, называемыми блоками или пакетами. При этом ядро операционной системы производит необходимую буферизацию. Примером физических устройств, соответствующих этому типу файлов, являются жесткие диски.
символьные устройства, т.е. использующие побайтную передачу данных.

Терминалы относятся к таким устройствам. 
Это разделение условно, так как одно и тоже устройство может иметь и символьный и блочный интерфейс (т.е. уметь передавать данные, как побайтно, так и блоками).

Все специальные файлы устройств хранятся в каталоге /dev. Например, файл, соответствующий устройству «жесткий диск» имеет имя hda, а файл, соответствующий первому виртуальному терминалу – tty0.
Для взаимодействия со специальными файлами устройств используются функции прямого доступа к файлам - open, read, write, close.

Системный вызов open используется для открытия файла. В качестве параметров в функцию передается строковая константа, соответствующая имени файла, который надо открыть, режим для открытия и дополнительные параметры.


В результате работы функции возвращается положительное целое число – номер дескриптора открытого файла, или -1, если во время открытия файла произошла ошибка. Дескриптор файла – это структура, описывающая файл. Хранится она в памяти пользовательской программы и может быть доступна по номеру дескриптора, который передается в качестве аргументов для функций, работающих с устройством.

Параметр flags определяет, в каком режиме требуется открыть файл. Он является целым числом, в котором за каждым битом однозначно устанавливается один требуемый режим. Для наглядности определения требуемых режимов в заголовочном файле fcntl.h библиотеки функций работы с файлами заданы соответствующие макросы. Например, режим открытия на чтение описывается макросом O_RDONLY, режим записи O_WRONLY, режим одновременной и записи и чтения (т.е. произвольного доступа) O_RDWR. Некоторые режимы могут комбинироваться. Например, режим записи может комбинироваться с режимом дополнения файла, т.е. flags будет выглядеть как O_APPEND | O_WRONLY.

Обратной по действию функции open является функция close, которая закрывает указанный дескриптор.

Чтение данных из устройства (точнее из его специального файла) производится с помощью функции read, которая в качестве параметров получает номер дескриптора, адрес буфера, куда необходимо поместить прочитанную информацию и максимальный размер этого буфера (т.е. может быть прочитано не более этого значения). Возвращает функций число прочитанных байтов или в случае ошибки -1.

Для передачи данных устройству (т.е. записи данных в специальный файл) используется вызов write. Параметры его аналогичны параметрам вызова read и возвращает он также число переданных байтов.



26. Терминалы. Типы терминалов. Эмуляция терминала. Режимы работы. Управление
терминалом. Команды. Низкоуровневое управление.

Терминал - это устройство, которое позволяет пользователю взаимодействовать с компьютерной системой. Существует несколько типов терминалов:

1. Текстовый терминал - это устройство, которое позволяет пользователю вводить текстовые команды и получать текстовые ответы от компьютера. Примером такого терминала может быть консольный интерфейс операционной системы.

2. Графический терминал - это устройство, которое позволяет пользователю взаимодействовать с компьютером через графический интерфейс. Примерами таких терминалов могут быть мониторы с сенсорным экраном или клавиатурой и мышью.

3. Терминал удаленного доступа - это устройство, которое позволяет пользователю подключаться к компьютеру удаленно через сеть. Примерами таких терминалов могут быть SSH-клиенты или программы для удаленного рабочего стола.

Эмуляция терминала - это процесс, при котором одно устройство эмулирует работу другого устройства. Например, программное обеспечение может эмулировать работу текстового терминала, чтобы пользователь мог взаимодействовать с компьютером через командную строку. Эмуляция терминала также может быть использована для подключения к удаленному компьютеру через сеть.
	

Режимы работы.
Ввод информации через терминал может осуществляться в одном из двух режимов:
каноническом, в котором информация передается в ЭВМ только в виде законченных строк (т.е. после нажатия клавиши «ВВОД» или “ENTER”); 
неканоническом, при котором вводимая информация сразу поступает в ЭВМ.

Управление терминалом.
Между драйвером и УУТ (устройство управления терминалом) передаются управляющие сообщения, которые позволяют настраивать УУТ на нужный режим работы и получать текущие его настройки. Программа пользователя также может управлять терминалом (например, передвинуть курсор на экране, или изменить цвет выводимых символов) путем передачи ему специальной последовательности символов, называемых командами терминала или управляющими кодами. Взаимодействовать напрямую с клавиатурой и монитором программа пользователя не может.
Формат и назначение команд терминала определяются его типом и (обычно) описываются производителем терминала в руководстве пользователя и в соответствующей программной среде (например, в ОС семейства UNIX используется база данных настроек терминала, называемая terminfo).

Команды
Управляющие коды (или управляющие символы) обычно состоят из первых 32 байтов алфавита ASCII. Они включают такие коды: возврат каретки (переместить курсор к левому краю экрана), перевод строки (переместить курсор вниз на одну строку), возврат на один символ, символ ESC, табуляция и звонок. Они обычно не показываются на экране.
Так как не имеется достаточного количества управляющих кодов, чтобы делать все, используются команды терминала, чаще всего называемые escape последовательностями. Они состоят из нескольких подряд идущих символов, первым из которых является символ с кодом ASCII 27, называемый "Escape" или ESC. Именно из-за первого символа команды терминала называются Escape-последовательностями.

27. Как происходит обработка сигнала в программах, работающих под управлением ОС Linux?

При получении сигнала процесс может выполнить одно из трех действий:

выполнить действие по умолчанию. Обычно действие по умолчанию заключается в прекращении выполнения процесса. Для некоторых сигналов, например, для сигналов SIGUSR1 и SIGUSR2, действие по умолчанию заключается в игнорировании сигнала. Для других сигналов, например, для сигнала SIGSTOP, действие по умолчанию заключается в остановке процесса;
игнорировать сигнал и продолжать выполнение. В больших программах неожиданно возникающие сигналы могут привести к проблемам. Например, нет смысла позволять программе останавливаться в результате случайного нажатия на клавишу прерывания, в то время как она производит обновление важной базы данных;
выполнить определенное пользователем действие. Программист может задать собственный обработчик сигнала. Например, выполнить при выходе из программы операции по «наведению порядка"

Чтобы определить действие, которое необходимо выполнить при получении сигнала, используется системный вызов signal:


Вызов signal определяет действие программы при поступлении сигнала с номером signum. Действие может быть задано как: адрес пользовательской функции (в таком случае в функцию в качестве параметра передается номер полученного сигнала) или как макросы SIG_IGN (для игнорирования сигнала) и SIG_DFL (для использования обработчика по умолчанию).

Если действие определено как пользовательская функция, то при поступлении сигнала программа будет прервана и процессор начнет выполнять указанную функцию. После её завершения выполнение программы, получившей сигнал, будет продолжено и обработчик сигнала будет установлен как SIG_DFL.






28. Что такое прерывание? Что такое сигнал? Чем они отличаются друг от друга? Какую информацию несут в себе прерывание и сигнал?

Прерывание – это событие, происходящие в ЭВМ, при котором процессор временно приостанавливает выполнение одной (текущей) программы и переключается на выполнение другой программы, необходимой для обработки этого события. После окончания выполнения обработчика события, вызвавшего прерывание, процессор возобновляет выполнение приостановленной программы. Такой подход позволяет устройствам, входящим в состав ЭВМ, функционировать независимо от процессора, и сообщать последнему о своей готовности взаимодействовать с ним. Кроме этого, использование прерываний позволяет реагировать на особые состояния, возникающие при работе самого процессора (т.е. при выполнении им программ).

Сигнал – это способ взаимодействия программ, позволяющий сообщать о наступлении определённых событий, например появление в очереди управляющих символов или возникновение ошибки во время работы программы (например, Segmentation Fauilt – выход за границы памяти).

Отличие
Сигнал - это событие, которое запускается процессором или программным обеспечением, которое работает на процессоре. Напротив, прерывание - это событие, которое запускается внешними компонентами, отличными от ЦП, которое предупреждает ЦП о выполнении определенного действия.

29. Каким образом настраивается таймер? Как программа «узнаёт» о срабатывании
таймера?

SIGALRM - сигнал таймера (alarm clock). Посылается процессу ядром при срабатывании таймера. Каждый процесс может устанавливать не менее трех таймеров. Первый из них измеряет прошедшее реальное время. Этот таймер устанавливается самим процессом при помощи системного вызовов alarm или setitimer (см. ниже);

Каждая программа в UNIX-подобных операционных системах может устанавливать три таймера:

ITIMER_REAL уменьшается постоянно и подает сигнал SIGALRM, когда значение таймера становится равным 0;
ITIMER_VIRTUAL уменьшается только во время работы процесса и подает сигнал SIGVTALRM, когда значение таймера становится равным 0.
ITIMER_PROF уменьшается во время работы процесса и когда система выполняет что-либо по заданию процесса. Совместно с ITIMER_VIRTUAL этот таймер обычно используется для профилирования времени работы приложения в пользовательской области и в области ядра. Когда значение таймера становится равным 0, подается сигнал SIGPROF.

Когда на одном из таймеров заканчивается время, процессу посылается сигнал и таймер обычно перезапускается.
Для установки таймеров используется функция setitimer. Величина, на которую устанавливается таймер, определяется следующими структурами:


Значение таймера уменьшается от величины it_value до нуля, после чего генерируется соответствующий сигнал, и значение таймера вновь устанавливается равным it_interval. Таймер, установленный на ноль (его величина it_value равна нулю или время вышло, и величина it_interval равна нулю), останавливается. Величины tv_sec и tv_usec являются основными при установке таймера.

Если устанавливаемое время срабатывания таймера измеряется в полных секундах, то для установки таймера может использоваться системный вызов alarm:


Функция alarm запускает таймер, который через secs секунд сгенерирует сигнал SIGALRM. Поэтому вызов alarm(60); приводит к посылке сигнала SIGALRM через 60 секунд. Обратите внимание, что вызов alarm не приостанавливает выполнение процесса, как вызов sleep, вместо этого сразу же происходит возврат из вызова alarm, и продолжается нормальное выполнение программы, по крайней мере, до тех пор, пока не будет получен сигнал SIGALRM. «Выключить» таймер можно при помощи вызова alarm с нулевым параметром: alarm(0).

Вызовы alarm не накапливаются. Другими словами, если вызвать alarm дважды, то второй вызов отменит предыдущий. Но при этом возвращаемое вызовом alarm значение будет равно времени, оставшемуся до срабатывания предыдущего таймера.

Пример программы, настраивающей терминал и обрабатывающей сигнал от него приведен в листинге 2.




30. Каким образом пользовательская программа может узнать об изменении размера окна виртуального терминала?

Как и аппаратное прерывание, сигналы описываются номерами, которые описаны в заголовочном файле signal.h. Кроме цифрового кода, каждый сигнал имеет соответствующее символьное обозначение, например SIGINT.
Большинство типов сигналов предназначены для использования ядром операционной системы, хотя есть несколько сигналов, которые посылаются от процесса к процессу. Приведем некоторые из них: SIGWINCH – сигнал, генерируемый драйвером терминала при изменении размеров окна;

Чтобы определить действие, которое необходимо выполнить при получении сигнала, используется системный вызов signal:


Вызов signal определяет действие программы при поступлении сигнала с номером signum. Действие может быть задано как: адрес пользовательской функции (в таком случае в функцию в качестве параметра передается номер полученного сигнала) или как макросы SIG_IGN (для игнорирования сигнала) и SIG_DFL (для использования обработчика по умолчанию).

Если действие определено как пользовательская функция, то при поступлении сигнала программа будет прервана и процессор начнет выполнять указанную функцию. После её завершения выполнение программы, получившей сигнал, будет продолжено и обработчик сигнала будет установлен как SIG_DFL.





31. Основные этапы загрузки ПК на базе процессоров семейства Intel.

Первым действием, которое выполняет компьютер при включении питания, является процедура загрузки, т.е. последовательность действий аппаратной части ПК по проверке состава (наличия или отсутствия тех или иных устройств) и запуска операционной системы.

Для современных персональных компьютеров с архитектурой IBM PC, построенных на основе семейства процессоров Intel (или совместимых с ним), процедура загрузки в общем случае выглядит следующим образом.

После нажатия кнопки «Power» источник питания выполняет самотестирование. Если все напряжения соответствуют номинальным величинам, то спустя некоторое время (примерно 0,1 - 0,5 с) он выдаёт на материнскую плату сигнал «PowerGood», после получения которого специальный триггер, вырабатывающий сигнал «RESET», снимает его с соответствующего входа микропроцессора. Далее сегментные регистры и указатель команд процессора устанавливаются в следующие состояния: CS = FFFFh; IP = 0; DS = SS = ES = 0. Все биты управляющих регистров и регистры арифметико-логического устройства устанавливаются в нулевое значение.

С момента снятия сигнала RESET микропроцессор начинает работу в реальном режиме, и, в течение примерно 7 циклов синхронизации, приступает к выполнению инструкции, считываемой из ROM BIOS, располагаемой по адресу FFFF:0000 (см. выше устанавливаемые значения регистров процессора). В этой области памяти содержится только команда перехода на реально исполняемый код BIOS. В этот момент процессор не может выполнять никакую другую последовательность команд, поскольку нигде в любой из областей памяти, кроме BIOS, её просто не существует.

Последовательно выполняя команды BIOS, процессор реализует функцию начального самотестирования POST (Power-On Self Test). На данном этапе тестируются процессор, память и системные средства ввода/вывода, а также производится конфигурирование программно-управляемых аппаратных средств материнской платы. Обнаружив ошибку, система определённым образом подаст звуковой сигнал.

В поисках встроенного драйвера видеоадаптера BIOS проверяет адреса памяти, начиная с 0000:0000 и заканчивая 0780:0000 (по умолчанию именно здесь должен располагаться такой драйвер). Если драйвер найден, проверяется контрольная сумма его кода, и, в случае совпадения с заданным значением, видеоадаптер инициализируется и выводится на экран курсор. В противном случае на экране появляется сообщение вида «С00 ROM Error». Если встроенный драйвер видеоадаптера не найден, то используется видеодрайвер, записанный в ПЗУ материнской платы, который пытается стандартным образом инициализировать видеоадаптер и вывести на экран курсор. Если и это не срабатывает, то видеоадаптер считается неисправным и подается соответствующий звуковой сигнал.
Далее сканируется память по адресам с С800:0000 по DF80:0000 с шагом 2 Кбайт в поисках встроенных драйверов любых других подключенных к материнской плате устройств (например, сетевых карт, модемов и т.п.). Обнаруженные драйверы выполняются так же, как и драйвер видеоадаптера. При несоответствии контрольных сумм выводится сообщение ХХХХ ROM Error, где ХХХХ - сегментный адрес некорректного драйвера.

После инициализации всех устройств BIOS проверяет значение слова по адресу 0000:0472, в котором содержится информация, корректирующая процесс дальнейшей проверки системы. Если здесь записано значение 1234h, то дальнейшая проверка устройств (включая оперативную память) не производится. Это возможно только в случае «горячей» перезагрузки ПК (например, при нажатии комбинации клавиш CTRL+ALT+DEL). В обычном режиме или при «холодной» перезагрузке (т.е. при нажатии клавиши RESET) здесь содержится значение 0000h.

В случае горячей загрузки, BIOS проверяет остальные подключенные устройства. Часть конфигурирования выполняется однозначно, а другая часть может определяться положением перемычек (переключателей) системной платы или содержимым энергонезависимой памяти CMOS. Для изменения CMOS используется утилита называемая «Setup», встроенная в BIOS.

Утилита Setup имеет интерфейс в виде меню или отдельных окон, иногда даже с поддержкой графики и мыши. Для запуска Setup во время выполнения POST появляется предложение нажать определённую комбинацию клавиш, например DEL.

После завершения POST BIOS определяет порядок поиска (boot sequence) внешних устройств, чтобы загрузить операционную систему (специальную программу, управляющую работой ПК). Этот порядок определяется одним из параметров, содержащихся в CMOS. Например, если последовательность определена как A, C, D, то сначала будет проверен дисковод и, если в нём находится дискета, BIOS попытается использовать её для загрузки ОС. Если дискета не обнаружена, то будет проверен диск C, затем D.

После того, как определено устройство, с которого будет происходить загрузка операционной системы, BIOS считывает с него информацию, располагаемую в самом начале, в оперативную память по адресу 0000:7С00. После чего проверяется, является ли это информация программой дальнейшей загрузки операционной системы. Если значения первых байтов считанного блока данных некорректные, на экране отображается сообщение об ошибке загрузочной записи и производится проверка следующего диска в списке. Если ни на одном из указанных носителей нет загрузочной программы, то на экран выводится сообщение об ошибке и загрузка системы останавливается.

С этого момента начинается загрузка операционной системы, процедура которой зависит от её типа.

32. Геометрия жесткого диска. Что это такое? Трансляция геометрии. Типы трансляции.

Геометрией диска называется совокупность характеристик, позволяющих определить максимальный объем хранимой информацией. Другими словами, геометрия - это максимальное число цилиндров (С), число головок (Н) и число секторов на дорожку (S).
Для того чтобы сохранить принцип преемственности программного обеспечения (т.е. чтобы на новой аппаратуре могли работать старые программы) используется трансляция CHS-адресации и геометрии в LBA и наоборот. Это преобразование осуществляется специальной программой – драйвером, который используется для доступа программ пользователя к информации на жестком диске.
Чаще всего, в качестве такого драйвера используется одна из функций BIOS. Однако некоторые операционные системы используют собственные драйверы и взаимодействуют напрямую с жестким диском.




33. LBA адресация. Зачем используется. Перевод из LBA в СНS лог и наоборот.

LBA (англ. Logical block addressing) — механизм адресации и доступа к блоку данных на жёстком или оптическом диске, при котором системному контроллеру нет необходимости учитывать геометрию самого жесткого диска (количество цилиндров, сторон, секторов на цилиндре). Контроллеры современных IDE дисков в качестве основного режима трансляции адреса используют LBA. 
LBA - это особенно простая схема линейной адресации ; блоки располагаются по целочисленному индексу, причем первый блок имеет значение LBA 0, второй LBA 1 и так далее.

Преобразования CHS/LBA и LBA/CHS

Адресация секторов может выполняться как в режиме CHS, так и в режиме LBA. Для данного накопителя существует определенное соответствие между адресациями CHS и LBA, которое, в частности, позволяет преобразовывать адреса CHS в адреса LBA и наоборот. Существует довольно простая формула, с помощью которой можно преобразовывать параметры CHS в LBA:

LBA = (((C × HPC) + H) × SPT) + S – 1.

Реверсирование этой формулы позволяет выполнить обратное преобразование, т.е. преобразовать параметры LBA в адрес CHS:

C = int (LBA/SPT/HPC),

H = int ((LBA/SPT) mod HPC),

S = (LBA mod SPT) + 1.

В этих формулах использованы следующие выражения:

- LBA — logical block address;

- C — цилиндр (cylinder);

- H — головка (head);

- S — сектор (sector);

- HPC — количество головок в каждом цилиндре (общее количество головок);

- SPT — количество секторов на каждой дорожке;

- int X — целочисленная часть X;

- X mod Y — модуль (остаток) от X/Y.

С помощью этих формул можно вычислить параметры LBA практически для любого адреса CHS и наоборот.

34. Адресация секторов жесткого диска. Типы адресации. Барьеры размеров дисков.
Почему возникли? Какие присутствуют?

Адресация секторов жесткого диска. Типы адресации. 

Минимальной адресуемой областью данных на жёстком диске является сектор. Размер сектора традиционно равен 512 байт.
Существует 2 основных способа адресации секторов на диске: цилиндр-головка-сектор (англ. cylinder-head-sector, CHS) и линейная адресация блоков (англ. linear block addressing, LBA).

CHS (от англ. Cylinder, Head, Sector — цилиндр, головка, сектор) — система адресации сектора, как минимальной единицы хранения данных в накопителях на жёстких магнитных дисках, накопителях на гибких магнитных дисках и т.п, основанная на использовании физических адресов геометрии диска.

В этой системе сектор адресуется кортежем из трёх координат: цилиндр-головка-сектор (Cylinder, Head, Sector), именно так, как он физически расположен на диске.

Под цилиндром понимается совокупность дорожек одинакового радиуса на всех магнитных поверхностях пластин одного накопителя.

LBA (англ. Logical block addressing) — механизм адресации и доступа к блоку данных на жёстком или оптическом диске, при котором системному контроллеру нет необходимости учитывать геометрию самого жесткого диска (количество цилиндров, сторон, секторов на цилиндре). Контроллеры современных IDE дисков в качестве основного режима трансляции адреса используют LBA.

Барьеры размеров дисков. Почему возникли? Какие присутствуют?

Стремясь сократить объем памяти, требуемый для адресации секторов на диске, в старых версиях BIOS были приняты ограничения для адресации секторов на диске. В них для "С" отводилось 10 бит, для "Н" отводилось 8 бит, для "S" отводилось 6 бит. Для хранения CHS адреса используется три 8-разрядных ячейки: первая - Н, вторая - 6 младших разрядов соответствуют номеру сектора, 2 старших – 2-м старшим разрядам номера цилиндра, третья ячейка – 8-мь младшим разрядам номера цилиндра.

Таким образом, получилось ограничение BIOS (или DOS, которая использовала только драйвер BIOS) в 8.5 ГБ. Сегодня это является серьезным ограничением на размер диска. А именно, DOS не в состоянии использовать большие диски, так как она использует только драйвер BIOS.

При использовании таких ограничений на величины C,H,S был получен очередной «барьер размера жесткого диска». Ограничения ATA и BIOS складываются так, что никто не может использовать больше чем 1024 цилиндра, 16 считывающих головок и 63 сектора, что составляет 528482304 байт (504 МБ).

35. Логическая организация винчестера. Разделы диска. Таблица разделов. Зачем используется. Структура.

Логическая организация винчестера.

Запись/чтение информации осуществляется магнитными головками, расположенными с обеих сторон диска. Магнитные головки, а следовательно, и стороны диска пронумерованы начиная с нуля. Подобно дискетам каждая сторона диска винчестера разбивается на дорожки и сектора. Совокупность дорожек, равноудаленных от центра дисков, образует цилиндр. Нумерация цилиндров, как и головок, начинается с нуля относительно внешнего края диска. Нумерация секторов на каждой дорожке начинается с единицы. Количество секторов на дорожке зависит от типа накопителя и может составлять несколько сотен. Порядковый номер головки, цилиндра и сектора на дорожке позволяет идентифицировать любой сектор винчестера.

В каждый сектор записывается служебная и полезная информация (данные), объем которой фиксирован (обычно составляет 571 байт). Служебная информация содержит заголовок (Prefix portion) и заключение (Suffix portion), которые располагаются в начале и конце каждого сектора. В заголовке записывается код, определяющий начало сектора и его номер, а в заключении указывается контрольная сумма, необходимая для проверки целостности данных. Между заголовком и заключением сектора находится область данных, объем которых для DOS составляет 512 байт. Запись полезной информации на дорожках осуществляется блоками по 512 байт.

Количество головок, цилиндрови секторов на дорожку винчестера устанавливается фирмой-изготовителем и определяет максимальную емкость памяти винчестера:

Логическая структура диска создается в процессе низкоуровневого форматирования (Low Level). Однако этого недостаточно для работоспособности винчестера после установки его в компьютер. Рассмотрим операции, которые необходимо выполнить для нормального функционирования винчестера.

В современных персональных компьютерах жесткие диски логически разделяются на одну или несколько областей, называемых разделами или томами. Это позволяет одновременно использовать несколько операционных систем на одном компьютере.

Информация о том, на какие разделы поделён жесткий диск, хранится в виде таблиц разделов, располагаемых в специально отведённых секторах. Обычно для формирования этих таблиц используются служебные программы, например FDISK.

Структура
Таблица разделов содержит 4 записи по 16 байт, описывающих части диска. Структура записи приведена в табл. 3. Обратим внимание, что в ней присутствует как CHS, так и LBA адресация для того, чтобы как старые операционные системы (работающие только по CHS), так и новые могли определить разбиение диска на разделы. При этом CHS адресация может описать разделы, начало и конец которых располагаются в области, не превышающей размер в 8 Гбайт.
